"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mysten+bcs@0.9.0";
exports.ids = ["vendor-chunks/@mysten+bcs@0.9.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.9.0/node_modules/@mysten/bcs/dist/index.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.9.0/node_modules/@mysten/bcs/dist/index.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BCS: () => (/* binding */ BCS),\n/* harmony export */   BcsReader: () => (/* binding */ BcsReader),\n/* harmony export */   BcsType: () => (/* binding */ BcsType),\n/* harmony export */   BcsWriter: () => (/* binding */ BcsWriter),\n/* harmony export */   SerializedBcs: () => (/* binding */ SerializedBcs),\n/* harmony export */   bcs: () => (/* binding */ bcs),\n/* harmony export */   decodeStr: () => (/* binding */ decodeStr),\n/* harmony export */   encodeStr: () => (/* binding */ encodeStr),\n/* harmony export */   fromB58: () => (/* binding */ fromB58),\n/* harmony export */   fromB64: () => (/* binding */ fromB64),\n/* harmony export */   fromHEX: () => (/* binding */ fromHEX),\n/* harmony export */   getRustConfig: () => (/* binding */ getRustConfig),\n/* harmony export */   getSuiMoveConfig: () => (/* binding */ getSuiMoveConfig),\n/* harmony export */   isSerializedBcs: () => (/* binding */ isSerializedBcs),\n/* harmony export */   registerPrimitives: () => (/* binding */ registerPrimitives),\n/* harmony export */   splitGenericParameters: () => (/* binding */ splitGenericParameters),\n/* harmony export */   toB58: () => (/* binding */ toB58),\n/* harmony export */   toB64: () => (/* binding */ toB64),\n/* harmony export */   toHEX: () => (/* binding */ toHEX)\n/* harmony export */ });\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js\");\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/b58.ts\n\nvar toB58 = (buffer) => bs58__WEBPACK_IMPORTED_MODULE_0__.encode(buffer);\nvar fromB58 = (str) => bs58__WEBPACK_IMPORTED_MODULE_0__.decode(str);\n\n// src/b64.ts\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n}\nfunction fromB64(sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n  return taBytes;\n}\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;\n}\nfunction toB64(aBytes) {\n  var nMod3 = 2, sB64Enc = \"\";\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(\n        uint6ToB64(nUint24 >>> 18 & 63),\n        uint6ToB64(nUint24 >>> 12 & 63),\n        uint6ToB64(nUint24 >>> 6 & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\");\n}\n\n// src/hex.ts\nfunction fromHEX(hexStr) {\n  const normalized = hexStr.startsWith(\"0x\") ? hexStr.slice(2) : hexStr;\n  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n  const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n  return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\n// src/uleb.ts\nfunction ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\n\n// src/reader.ts\nvar BcsReader = class {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let { value, length } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n};\n\n// src/utils.ts\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction splitGenericParameters(str, genericSeparators = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\n\n// src/writer.ts\nvar BcsWriter = class {\n  constructor({ size = 1024, maxSize, allocateSize = 1024 } = {}) {\n    this.bytePosition = 0;\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n};\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\n\n// src/bcs-type.ts\nvar _write, _serialize;\nvar _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write, void 0);\n    __privateAdd(this, _serialize, void 0);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({ size: this.serializedSize(value) ?? void 0, ...options2 });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {\n    });\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  transform({\n    name,\n    input,\n    output\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: (reader) => output(this.read(reader)),\n      write: (value, writer) => __privateGet(this, _write).call(this, input(value), writer),\n      serializedSize: (value) => this.serializedSize(input(value)),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input(value), options),\n      validate: (value) => this.validate(input(value))\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nvar BcsType = _BcsType;\nvar SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nvar _schema, _bytes;\nvar SerializedBcs = class {\n  constructor(type, schema) {\n    __privateAdd(this, _schema, void 0);\n    __privateAdd(this, _bytes, void 0);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHEX(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toB64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toB58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n};\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: (value) => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: (val) => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: (reader) => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: (value) => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: (value) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: (data) => getType().read(data),\n    serializedSize: (value) => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\n\n// src/bcs.ts\nvar bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: (reader) => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: (reader) => reader.readULEB(),\n      serialize: (value) => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: (reader) => reader.readBytes(size),\n      write: (value, writer) => {\n        for (let i = 0; i < size; i++) {\n          writer.write8(value[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: (value) => new TextEncoder().encode(value),\n      fromBytes: (bytes) => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: (reader) => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: (value) => {\n        if (value == null) {\n          return { None: true };\n        }\n        return { Some: value };\n      },\n      output: (value) => {\n        if (\"Some\" in value) {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: (reader) => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map((t) => t.name).join(\", \")})`,\n      serializedSize: (values) => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: (values) => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: (reader) => {\n        const index = reader.readULEB();\n        const [name2, type] = canonicalOrder[index];\n        return {\n          [name2]: type?.read(reader) ?? true\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value)[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value);\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, found ${keys.length}`);\n        }\n        const [name2] = keys;\n        if (!Object.hasOwn(values, name2)) {\n          throw new TypeError(`Invalid enum variant ${name2}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: (value) => {\n        return [...value.entries()];\n      },\n      output: (value) => {\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * @deprecated\n   *\n   * Generics should be implemented as generic typescript functions instead:\n   *\n   * ```ts\n   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n   *   return bcs.struct('VecMap<K, V>', {\n   *     keys: bcs.vector(K),\n   *     values: bcs.vector(V),\n   *   })\n   * }\n   * ```\n   */\n  generic(names, cb) {\n    return (...types) => {\n      return cb(...types).transform({\n        name: `${cb.name}<${types.map((t) => t.name).join(\", \")}>`,\n        input: (value) => value,\n        output: (value) => value\n      });\n    };\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\n\n// src/legacy-registry.ts\nvar SUI_ADDRESS_LENGTH = 32;\nvar _BCS = class _BCS {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */ new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {\n    const { name, params: generics } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, { [value]: typeParams[index] });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, { [value]: typeParams[index] });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n  \t * Method to register BcsType instances to the registry\n  \t * Types are registered with a callback that provides BcsType instances for each generic\n  \t * passed to the type.\n  \t *\n  \t * - createType(...generics) - Return a BcsType instance\n  \t *\n  \t * @example\n  \t * // our type would be a string that consists only of numbers\n  \t * bcs.registerType('Box<T>', (T) => {\n  \t * \t\treturn bcs.struct({\n  \t * \t\t\tvalue: T\n  \t * \t\t});\n  \t * });\n  \n  \t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n  \t *\n  \t * @param name\n  \t * @param createType a Callback to create the BcsType with any passed in generics\n  \t */\n  registerBcsType(typeName, createType) {\n    this.registerType(\n      typeName,\n      (writer, data, typeParams) => {\n        const generics = typeParams.map(\n          (param) => new BcsType({\n            name: String(param),\n            write: (data2, writer2) => {\n              const { name, params } = this.parseTypeName(param);\n              const typeInterface = this.getTypeInterface(name);\n              const typeMap = params.reduce((acc, value, index) => {\n                return Object.assign(acc, { [value]: typeParams[index] });\n              }, {});\n              return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);\n            },\n            read: () => {\n              throw new Error(\"Not implemented\");\n            }\n          })\n        );\n        createType(...generics).write(data, writer);\n        return writer;\n      },\n      (reader, typeParams) => {\n        const generics = typeParams.map(\n          (param) => new BcsType({\n            name: String(param),\n            write: (data, writer) => {\n              throw new Error(\"Not implemented\");\n            },\n            read: (reader2) => {\n              const { name, params } = this.parseTypeName(param);\n              const typeInterface = this.getTypeInterface(name);\n              const typeMap = params.reduce((acc, value, index) => {\n                return Object.assign(acc, { [value]: typeParams[index] });\n              }, {});\n              return typeInterface._decodeRaw.call(this, reader2, params, typeMap);\n            }\n          })\n        );\n        return createType(...generics).read(reader);\n      }\n    );\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length, encoding = \"hex\") {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data) {\n            return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n          },\n          function decodeAddress(reader) {\n            return toB64(reader.readBytes(length));\n          }\n        );\n      case \"hex\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data) {\n            return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n          },\n          function decodeAddress(reader) {\n            return toHEX(reader.readBytes(length));\n          }\n        );\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let { name, params } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(\n      typeName,\n      function encodeVector(writer, data, typeParams, typeMap) {\n        return writer.writeVec(data, (writer2, el) => {\n          let elementType = typeParams[0];\n          if (!elementType) {\n            throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n          }\n          let { name: name2, params: params2 } = this.parseTypeName(elementType);\n          if (this.hasType(name2)) {\n            return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n          }\n          if (!(name2 in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`\n            );\n          }\n          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n          return this.getTypeInterface(innerName)._encodeRaw.call(\n            this,\n            writer2,\n            el,\n            innerParams,\n            typeMap\n          );\n        });\n      },\n      function decodeVector(reader, typeParams, typeMap) {\n        return reader.readVec((reader2) => {\n          let elementType = typeParams[0];\n          if (!elementType) {\n            throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n          }\n          let { name: name2, params: params2 } = this.parseTypeName(elementType);\n          if (this.hasType(name2)) {\n            return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n          }\n          if (!(name2 in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`\n            );\n          }\n          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n          return this.getTypeInterface(innerName)._decodeRaw.call(\n            this,\n            reader2,\n            innerParams,\n            typeMap\n          );\n        });\n      }\n    );\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let { name: structName, params: generics } = this.parseTypeName(typeName);\n    return this.registerType(\n      typeName,\n      function encodeStruct(writer, data, typeParams, typeMap) {\n        if (!data || data.constructor !== Object) {\n          throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n        }\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n        for (let key of canonicalOrder) {\n          if (!(key in data)) {\n            throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n          }\n          const { name: fieldType, params: fieldParams } = this.parseTypeName(\n            struct[key]\n          );\n          if (!generics.includes(fieldType)) {\n            this.getTypeInterface(fieldType)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldType);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n            if (this.hasType(name)) {\n              this.getTypeInterface(name)._encodeRaw.call(\n                this,\n                writer,\n                data[key],\n                params,\n                typeMap\n              );\n              continue;\n            }\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n            this.getTypeInterface(innerName)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return writer;\n      },\n      function decodeStruct(reader, typeParams, typeMap) {\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n        let result = {};\n        for (let key of canonicalOrder) {\n          const { name: fieldName, params: fieldParams } = this.parseTypeName(\n            struct[key]\n          );\n          if (!generics.includes(fieldName)) {\n            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n              this,\n              reader,\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldName);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n            if (this.hasType(name)) {\n              result[key] = this.getTypeInterface(name)._decodeRaw.call(\n                this,\n                reader,\n                params,\n                typeMap\n              );\n              continue;\n            }\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n              this,\n              reader,\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return result;\n      }\n    );\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n    return this.registerType(\n      typeName,\n      function encodeEnum(writer, data, typeParams, typeMap) {\n        if (!data) {\n          throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n        }\n        if (typeof data !== \"object\") {\n          throw new Error(\n            `Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n              \" | \"\n            )}\".\nReceived: \"${JSON.stringify(data)}\"`\n          );\n        }\n        let key = Object.keys(data)[0];\n        if (key === void 0) {\n          throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n        }\n        let orderByte = canonicalOrder.indexOf(key);\n        if (orderByte === -1) {\n          throw new Error(\n            `Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n              \" | \"\n            )}\"; received \"${key}\"`\n          );\n        }\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant];\n        writer.write8(orderByte);\n        if (invariantType === null) {\n          return writer;\n        }\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n        {\n          let { name: name2, params } = this.parseTypeName(typeOrParam);\n          return this.getTypeInterface(name2)._encodeRaw.call(\n            this,\n            writer,\n            data[key],\n            params,\n            typeMap\n          );\n        }\n      },\n      function decodeEnum(reader, typeParams, typeMap) {\n        let orderByte = reader.readULEB();\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant];\n        if (orderByte === -1) {\n          throw new Error(\n            `Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`\n          );\n        }\n        if (invariantType === null) {\n          return { [invariant]: true };\n        }\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n        {\n          let { name: name2, params } = this.parseTypeName(typeOrParam);\n          return {\n            [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n          };\n        }\n      }\n    );\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return { name: typeName2, params: params2 };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return { name, params: [] };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = splitGenericParameters(\n      name.slice(l_bound + 1, name.length - r_bound - 1),\n      this.schema.genericSeparators\n    );\n    return { name: typeName, params };\n  }\n};\n// Predefined types constants\n_BCS.U8 = \"u8\";\n_BCS.U16 = \"u16\";\n_BCS.U32 = \"u32\";\n_BCS.U64 = \"u64\";\n_BCS.U128 = \"u128\";\n_BCS.U256 = \"u256\";\n_BCS.BOOL = \"bool\";\n_BCS.VECTOR = \"vector\";\n_BCS.ADDRESS = \"address\";\n_BCS.STRING = \"string\";\n_BCS.HEX = \"hex-string\";\n_BCS.BASE58 = \"base58-string\";\n_BCS.BASE64 = \"base64-string\";\nvar BCS = _BCS;\nfunction registerPrimitives(bcs2) {\n  bcs2.registerType(\n    BCS.U8,\n    function(writer, data) {\n      return writer.write8(data);\n    },\n    function(reader) {\n      return reader.read8();\n    },\n    (u8) => u8 < 256\n  );\n  bcs2.registerType(\n    BCS.U16,\n    function(writer, data) {\n      return writer.write16(data);\n    },\n    function(reader) {\n      return reader.read16();\n    },\n    (u16) => u16 < 65536\n  );\n  bcs2.registerType(\n    BCS.U32,\n    function(writer, data) {\n      return writer.write32(data);\n    },\n    function(reader) {\n      return reader.read32();\n    },\n    (u32) => u32 <= 4294967296n\n  );\n  bcs2.registerType(\n    BCS.U64,\n    function(writer, data) {\n      return writer.write64(data);\n    },\n    function(reader) {\n      return reader.read64();\n    }\n  );\n  bcs2.registerType(\n    BCS.U128,\n    function(writer, data) {\n      return writer.write128(data);\n    },\n    function(reader) {\n      return reader.read128();\n    }\n  );\n  bcs2.registerType(\n    BCS.U256,\n    function(writer, data) {\n      return writer.write256(data);\n    },\n    function(reader) {\n      return reader.read256();\n    }\n  );\n  bcs2.registerType(\n    BCS.BOOL,\n    function(writer, data) {\n      return writer.write8(data);\n    },\n    function(reader) {\n      return reader.read8().toString(10) === \"1\";\n    }\n  );\n  bcs2.registerType(\n    BCS.STRING,\n    function(writer, data) {\n      return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n    },\n    function(reader) {\n      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join(\"\");\n    },\n    (_str) => true\n  );\n  bcs2.registerType(\n    BCS.HEX,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toHEX(new Uint8Array(bytes));\n    }\n  );\n  bcs2.registerType(\n    BCS.BASE58,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toB58(new Uint8Array(bytes));\n    }\n  );\n  bcs2.registerType(\n    BCS.BASE64,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toB64(new Uint8Array(bytes));\n    }\n  );\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC45LjAvbm9kZV9tb2R1bGVzL0BteXN0ZW4vYmNzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3dCO0FBQ3hCLHdCQUF3Qix3Q0FBVztBQUNuQyx1QkFBdUIsd0NBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFLGlDQUFpQyxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlEQUF5RDtBQUM5RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYyxTQUFTLE1BQU0sOEJBQThCLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYyxTQUFTLE1BQU0sOEJBQThCLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYyxTQUFTLE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWE7QUFDdEU7QUFDQTtBQUNBLEtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvdXNlci9Eb3dubG9hZHMvc3VpY2FydHQvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BteXN0ZW4rYmNzQDAuOS4wL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL2I1OC50c1xuaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcbnZhciB0b0I1OCA9IChidWZmZXIpID0+IGJzNTguZW5jb2RlKGJ1ZmZlcik7XG52YXIgZnJvbUI1OCA9IChzdHIpID0+IGJzNTguZGVjb2RlKHN0cik7XG5cbi8vIHNyYy9iNjQudHNcbmZ1bmN0aW9uIGI2NFRvVWludDYobkNocikge1xuICByZXR1cm4gbkNociA+IDY0ICYmIG5DaHIgPCA5MSA/IG5DaHIgLSA2NSA6IG5DaHIgPiA5NiAmJiBuQ2hyIDwgMTIzID8gbkNociAtIDcxIDogbkNociA+IDQ3ICYmIG5DaHIgPCA1OCA/IG5DaHIgKyA0IDogbkNociA9PT0gNDMgPyA2MiA6IG5DaHIgPT09IDQ3ID8gNjMgOiAwO1xufVxuZnVuY3Rpb24gZnJvbUI2NChzQmFzZTY0LCBuQmxvY2tzU2l6ZSkge1xuICB2YXIgc0I2NEVuYyA9IHNCYXNlNjQucmVwbGFjZSgvW15BLVphLXowLTkrL10vZywgXCJcIiksIG5JbkxlbiA9IHNCNjRFbmMubGVuZ3RoLCBuT3V0TGVuID0gbkJsb2Nrc1NpemUgPyBNYXRoLmNlaWwoKG5JbkxlbiAqIDMgKyAxID4+IDIpIC8gbkJsb2Nrc1NpemUpICogbkJsb2Nrc1NpemUgOiBuSW5MZW4gKiAzICsgMSA+PiAyLCB0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobk91dExlbik7XG4gIGZvciAodmFyIG5Nb2QzLCBuTW9kNCwgblVpbnQyNCA9IDAsIG5PdXRJZHggPSAwLCBuSW5JZHggPSAwOyBuSW5JZHggPCBuSW5MZW47IG5JbklkeCsrKSB7XG4gICAgbk1vZDQgPSBuSW5JZHggJiAzO1xuICAgIG5VaW50MjQgfD0gYjY0VG9VaW50NihzQjY0RW5jLmNoYXJDb2RlQXQobkluSWR4KSkgPDwgNiAqICgzIC0gbk1vZDQpO1xuICAgIGlmIChuTW9kNCA9PT0gMyB8fCBuSW5MZW4gLSBuSW5JZHggPT09IDEpIHtcbiAgICAgIGZvciAobk1vZDMgPSAwOyBuTW9kMyA8IDMgJiYgbk91dElkeCA8IG5PdXRMZW47IG5Nb2QzKyssIG5PdXRJZHgrKykge1xuICAgICAgICB0YUJ5dGVzW25PdXRJZHhdID0gblVpbnQyNCA+Pj4gKDE2ID4+PiBuTW9kMyAmIDI0KSAmIDI1NTtcbiAgICAgIH1cbiAgICAgIG5VaW50MjQgPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFCeXRlcztcbn1cbmZ1bmN0aW9uIHVpbnQ2VG9CNjQoblVpbnQ2KSB7XG4gIHJldHVybiBuVWludDYgPCAyNiA/IG5VaW50NiArIDY1IDogblVpbnQ2IDwgNTIgPyBuVWludDYgKyA3MSA6IG5VaW50NiA8IDYyID8gblVpbnQ2IC0gNCA6IG5VaW50NiA9PT0gNjIgPyA0MyA6IG5VaW50NiA9PT0gNjMgPyA0NyA6IDY1O1xufVxuZnVuY3Rpb24gdG9CNjQoYUJ5dGVzKSB7XG4gIHZhciBuTW9kMyA9IDIsIHNCNjRFbmMgPSBcIlwiO1xuICBmb3IgKHZhciBuTGVuID0gYUJ5dGVzLmxlbmd0aCwgblVpbnQyNCA9IDAsIG5JZHggPSAwOyBuSWR4IDwgbkxlbjsgbklkeCsrKSB7XG4gICAgbk1vZDMgPSBuSWR4ICUgMztcbiAgICBuVWludDI0IHw9IGFCeXRlc1tuSWR4XSA8PCAoMTYgPj4+IG5Nb2QzICYgMjQpO1xuICAgIGlmIChuTW9kMyA9PT0gMiB8fCBhQnl0ZXMubGVuZ3RoIC0gbklkeCA9PT0gMSkge1xuICAgICAgc0I2NEVuYyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChcbiAgICAgICAgdWludDZUb0I2NChuVWludDI0ID4+PiAxOCAmIDYzKSxcbiAgICAgICAgdWludDZUb0I2NChuVWludDI0ID4+PiAxMiAmIDYzKSxcbiAgICAgICAgdWludDZUb0I2NChuVWludDI0ID4+PiA2ICYgNjMpLFxuICAgICAgICB1aW50NlRvQjY0KG5VaW50MjQgJiA2MylcbiAgICAgICk7XG4gICAgICBuVWludDI0ID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNCNjRFbmMuc2xpY2UoMCwgc0I2NEVuYy5sZW5ndGggLSAyICsgbk1vZDMpICsgKG5Nb2QzID09PSAyID8gXCJcIiA6IG5Nb2QzID09PSAxID8gXCI9XCIgOiBcIj09XCIpO1xufVxuXG4vLyBzcmMvaGV4LnRzXG5mdW5jdGlvbiBmcm9tSEVYKGhleFN0cikge1xuICBjb25zdCBub3JtYWxpemVkID0gaGV4U3RyLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGhleFN0ci5zbGljZSgyKSA6IGhleFN0cjtcbiAgY29uc3QgcGFkZGVkID0gbm9ybWFsaXplZC5sZW5ndGggJSAyID09PSAwID8gbm9ybWFsaXplZCA6IGAwJHtub3JtYWxpemVkfX1gO1xuICBjb25zdCBpbnRBcnIgPSBwYWRkZWQubWF0Y2goLy57Mn0vZyk/Lm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSA/PyBbXTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShpbnRBcnIpO1xufVxuZnVuY3Rpb24gdG9IRVgoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuXG4vLyBzcmMvdWxlYi50c1xuZnVuY3Rpb24gdWxlYkVuY29kZShudW0pIHtcbiAgbGV0IGFyciA9IFtdO1xuICBsZXQgbGVuID0gMDtcbiAgaWYgKG51bSA9PT0gMCkge1xuICAgIHJldHVybiBbMF07XG4gIH1cbiAgd2hpbGUgKG51bSA+IDApIHtcbiAgICBhcnJbbGVuXSA9IG51bSAmIDEyNztcbiAgICBpZiAobnVtID4+PSA3KSB7XG4gICAgICBhcnJbbGVuXSB8PSAxMjg7XG4gICAgfVxuICAgIGxlbiArPSAxO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiB1bGViRGVjb2RlKGFycikge1xuICBsZXQgdG90YWwgPSAwO1xuICBsZXQgc2hpZnQgPSAwO1xuICBsZXQgbGVuID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgYnl0ZSA9IGFycltsZW5dO1xuICAgIGxlbiArPSAxO1xuICAgIHRvdGFsIHw9IChieXRlICYgMTI3KSA8PCBzaGlmdDtcbiAgICBpZiAoKGJ5dGUgJiAxMjgpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2hpZnQgKz0gNztcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB0b3RhbCxcbiAgICBsZW5ndGg6IGxlblxuICB9O1xufVxuXG4vLyBzcmMvcmVhZGVyLnRzXG52YXIgQmNzUmVhZGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIERhdGEgdG8gdXNlIGFzIGEgYnVmZmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uID0gMDtcbiAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogU2hpZnQgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gYnkgYGJ5dGVzYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzIE51bWJlciBvZiBieXRlcyB0b1xuICAgKiBAcmV0dXJucyB7dGhpc30gU2VsZiBmb3IgcG9zc2libGUgY2hhaW5pbmcuXG4gICAqL1xuICBzaGlmdChieXRlcykge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uICs9IGJ5dGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIFU4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDEuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZWFkOCgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KHRoaXMuYnl0ZVBvc2l0aW9uKTtcbiAgICB0aGlzLnNoaWZ0KDEpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTYgdmFsdWUgZnJvbSB0aGUgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgYnkgMi5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHJlYWQxNigpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNih0aGlzLmJ5dGVQb3NpdGlvbiwgdHJ1ZSk7XG4gICAgdGhpcy5zaGlmdCgyKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgVTMyIHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDQuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZWFkMzIoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIodGhpcy5ieXRlUG9zaXRpb24sIHRydWUpO1xuICAgIHRoaXMuc2hpZnQoNCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIFU2NCB2YWx1ZSBmcm9tIHRoZSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBieSA4LlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVhZDY0KCkge1xuICAgIGxldCB2YWx1ZTEgPSB0aGlzLnJlYWQzMigpO1xuICAgIGxldCB2YWx1ZTIgPSB0aGlzLnJlYWQzMigpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZTIudG9TdHJpbmcoMTYpICsgdmFsdWUxLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gICAgcmV0dXJuIEJpZ0ludChcIjB4XCIgKyByZXN1bHQpLnRvU3RyaW5nKDEwKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTI4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDE2LlxuICAgKi9cbiAgcmVhZDEyOCgpIHtcbiAgICBsZXQgdmFsdWUxID0gQmlnSW50KHRoaXMucmVhZDY0KCkpO1xuICAgIGxldCB2YWx1ZTIgPSBCaWdJbnQodGhpcy5yZWFkNjQoKSk7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlMi50b1N0cmluZygxNikgKyB2YWx1ZTEudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCBcIjBcIik7XG4gICAgcmV0dXJuIEJpZ0ludChcIjB4XCIgKyByZXN1bHQpLnRvU3RyaW5nKDEwKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTI4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDMyLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVhZDI1NigpIHtcbiAgICBsZXQgdmFsdWUxID0gQmlnSW50KHRoaXMucmVhZDEyOCgpKTtcbiAgICBsZXQgdmFsdWUyID0gQmlnSW50KHRoaXMucmVhZDEyOCgpKTtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUyLnRvU3RyaW5nKDE2KSArIHZhbHVlMS50b1N0cmluZygxNikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICByZXR1cm4gQmlnSW50KFwiMHhcIiArIHJlc3VsdCkudG9TdHJpbmcoMTApO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGBudW1gIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBieSBgbnVtYC5cbiAgICogQHBhcmFtIG51bSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICovXG4gIHJlYWRCeXRlcyhudW0pIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLmJ5dGVQb3NpdGlvbiArIHRoaXMuZGF0YVZpZXcuYnl0ZU9mZnNldDtcbiAgICBsZXQgdmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGFWaWV3LmJ1ZmZlciwgc3RhcnQsIG51bSk7XG4gICAgdGhpcy5zaGlmdChudW0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVTEVCIHZhbHVlIC0gYW4gaW50ZWdlciBvZiB2YXJ5aW5nIHNpemUuIFVzZWQgZm9yIGVudW0gaW5kZXhlcyBhbmRcbiAgICogdmVjdG9yIGxlbmd0aHMuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBVTEVCIHZhbHVlLlxuICAgKi9cbiAgcmVhZFVMRUIoKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5ieXRlUG9zaXRpb24gKyB0aGlzLmRhdGFWaWV3LmJ5dGVPZmZzZXQ7XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YVZpZXcuYnVmZmVyLCBzdGFydCk7XG4gICAgbGV0IHsgdmFsdWUsIGxlbmd0aCB9ID0gdWxlYkRlY29kZShidWZmZXIpO1xuICAgIHRoaXMuc2hpZnQobGVuZ3RoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBCQ1MgdmVjdG9yOiByZWFkIGEgbGVuZ3RoIGFuZCB0aGVuIGFwcGx5IGZ1bmN0aW9uIGBjYmAgWCB0aW1lc1xuICAgKiB3aGVyZSBYIGlzIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciwgZGVmaW5lZCBhcyBVTEVCIGluIEJDUyBieXRlcy5cbiAgICogQHBhcmFtIGNiIENhbGxiYWNrIHRvIHByb2Nlc3MgZWxlbWVudHMgb2YgdmVjdG9yLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8QW55Pn0gQXJyYXkgb2YgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIHJldHVybmVkIGJ5IGNhbGxiYWNrLlxuICAgKi9cbiAgcmVhZFZlYyhjYikge1xuICAgIGxldCBsZW5ndGggPSB0aGlzLnJlYWRVTEVCKCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNiKHRoaXMsIGksIGxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGVuY29kZVN0cihkYXRhLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSBcImJhc2U1OFwiOlxuICAgICAgcmV0dXJuIHRvQjU4KGRhdGEpO1xuICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgIHJldHVybiB0b0I2NChkYXRhKTtcbiAgICBjYXNlIFwiaGV4XCI6XG4gICAgICByZXR1cm4gdG9IRVgoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nLCBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogYmFzZTY0LCBoZXhcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZVN0cihkYXRhLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSBcImJhc2U1OFwiOlxuICAgICAgcmV0dXJuIGZyb21CNTgoZGF0YSk7XG4gICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgcmV0dXJuIGZyb21CNjQoZGF0YSk7XG4gICAgY2FzZSBcImhleFwiOlxuICAgICAgcmV0dXJuIGZyb21IRVgoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nLCBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogYmFzZTY0LCBoZXhcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0R2VuZXJpY1BhcmFtZXRlcnMoc3RyLCBnZW5lcmljU2VwYXJhdG9ycyA9IFtcIjxcIiwgXCI+XCJdKSB7XG4gIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZW5lcmljU2VwYXJhdG9ycztcbiAgY29uc3QgdG9rID0gW107XG4gIGxldCB3b3JkID0gXCJcIjtcbiAgbGV0IG5lc3RlZEFuZ2xlQnJhY2tldHMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07XG4gICAgaWYgKGNoYXIgPT09IGxlZnQpIHtcbiAgICAgIG5lc3RlZEFuZ2xlQnJhY2tldHMrKztcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IHJpZ2h0KSB7XG4gICAgICBuZXN0ZWRBbmdsZUJyYWNrZXRzLS07XG4gICAgfVxuICAgIGlmIChuZXN0ZWRBbmdsZUJyYWNrZXRzID09PSAwICYmIGNoYXIgPT09IFwiLFwiKSB7XG4gICAgICB0b2sucHVzaCh3b3JkLnRyaW0oKSk7XG4gICAgICB3b3JkID0gXCJcIjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3b3JkICs9IGNoYXI7XG4gIH1cbiAgdG9rLnB1c2god29yZC50cmltKCkpO1xuICByZXR1cm4gdG9rO1xufVxuXG4vLyBzcmMvd3JpdGVyLnRzXG52YXIgQmNzV3JpdGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHNpemUgPSAxMDI0LCBtYXhTaXplLCBhbGxvY2F0ZVNpemUgPSAxMDI0IH0gPSB7fSkge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemUgfHwgc2l6ZTtcbiAgICB0aGlzLmFsbG9jYXRlU2l6ZSA9IGFsbG9jYXRlU2l6ZTtcbiAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihzaXplKSk7XG4gIH1cbiAgZW5zdXJlU2l6ZU9yR3JvdyhieXRlcykge1xuICAgIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IHRoaXMuYnl0ZVBvc2l0aW9uICsgYnl0ZXM7XG4gICAgaWYgKHJlcXVpcmVkU2l6ZSA+IHRoaXMuc2l6ZSkge1xuICAgICAgY29uc3QgbmV4dFNpemUgPSBNYXRoLm1pbih0aGlzLm1heFNpemUsIHRoaXMuc2l6ZSArIHRoaXMuYWxsb2NhdGVTaXplKTtcbiAgICAgIGlmIChyZXF1aXJlZFNpemUgPiBuZXh0U2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIHRvIEJDUywgYnV0IGJ1ZmZlciBkb2VzIG5vdCBoYXZlIGVub3VnaCBzaXplLiBBbGxvY2F0ZWQgc2l6ZTogJHt0aGlzLnNpemV9LCBNYXggc2l6ZTogJHt0aGlzLm1heFNpemV9LCBSZXF1aXJlZCBzaXplOiAke3JlcXVpcmVkU2l6ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpemUgPSBuZXh0U2l6ZTtcbiAgICAgIGNvbnN0IG5leHRCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KG5leHRCdWZmZXIpLnNldChuZXcgVWludDhBcnJheSh0aGlzLmRhdGFWaWV3LmJ1ZmZlcikpO1xuICAgICAgdGhpcy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXh0QnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNoaWZ0IGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGJ5IGBieXRlc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyBOdW1iZXIgb2YgYnl0ZXMgdG9cbiAgICogQHJldHVybnMge3RoaXN9IFNlbGYgZm9yIHBvc3NpYmxlIGNoYWluaW5nLlxuICAgKi9cbiAgc2hpZnQoYnl0ZXMpIHtcbiAgICB0aGlzLmJ5dGVQb3NpdGlvbiArPSBieXRlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVOCB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgMS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlOCh2YWx1ZSkge1xuICAgIHRoaXMuZW5zdXJlU2l6ZU9yR3JvdygxKTtcbiAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQ4KHRoaXMuYnl0ZVBvc2l0aW9uLCBOdW1iZXIodmFsdWUpKTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgxKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVMTYgdmFsdWUgaW50byBhIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIHBvc2l0aW9uIGJ5IDIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZTE2KHZhbHVlKSB7XG4gICAgdGhpcy5lbnN1cmVTaXplT3JHcm93KDIpO1xuICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMuYnl0ZVBvc2l0aW9uLCBOdW1iZXIodmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCgyKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVMzIgdmFsdWUgaW50byBhIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIHBvc2l0aW9uIGJ5IDQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZTMyKHZhbHVlKSB7XG4gICAgdGhpcy5lbnN1cmVTaXplT3JHcm93KDQpO1xuICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDMyKHRoaXMuYnl0ZVBvc2l0aW9uLCBOdW1iZXIodmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5zaGlmdCg0KTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVNjQgdmFsdWUgaW50byBhIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIHBvc2l0aW9uIGJ5IDguXG4gICAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZSBWYWx1ZSB0byB3cml0ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZTY0KHZhbHVlKSB7XG4gICAgdG9MaXR0bGVFbmRpYW4oQmlnSW50KHZhbHVlKSwgOCkuZm9yRWFjaCgoZWwpID0+IHRoaXMud3JpdGU4KGVsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgVTEyOCB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgMTYuXG4gICAqXG4gICAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZSBWYWx1ZSB0byB3cml0ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZTEyOCh2YWx1ZSkge1xuICAgIHRvTGl0dGxlRW5kaWFuKEJpZ0ludCh2YWx1ZSksIDE2KS5mb3JFYWNoKChlbCkgPT4gdGhpcy53cml0ZTgoZWwpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVMjU2IHZhbHVlIGludG8gYSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBwb3NpdGlvbiBieSAxNi5cbiAgICpcbiAgICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlMjU2KHZhbHVlKSB7XG4gICAgdG9MaXR0bGVFbmRpYW4oQmlnSW50KHZhbHVlKSwgMzIpLmZvckVhY2goKGVsKSA9PiB0aGlzLndyaXRlOChlbCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFVMRUIgdmFsdWUgaW50byBhIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIHBvc2l0aW9uIGJ5IG51bWJlciBvZiBieXRlc1xuICAgKiB3cml0dGVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGUuXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgd3JpdGVVTEVCKHZhbHVlKSB7XG4gICAgdWxlYkVuY29kZSh2YWx1ZSkuZm9yRWFjaCgoZWwpID0+IHRoaXMud3JpdGU4KGVsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgdmVjdG9yIGludG8gYSBidWZmZXIgYnkgZmlyc3Qgd3JpdGluZyB0aGUgdmVjdG9yIGxlbmd0aCBhbmQgdGhlbiBjYWxsaW5nXG4gICAqIGEgY2FsbGJhY2sgb24gZWFjaCBwYXNzZWQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8QW55Pn0gdmVjdG9yIEFycmF5IG9mIGVsZW1lbnRzIHRvIHdyaXRlLlxuICAgKiBAcGFyYW0ge1dyaXRlVmVjQ2J9IGNiIENhbGxiYWNrIHRvIGNhbGwgb24gZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgd3JpdGVWZWModmVjdG9yLCBjYikge1xuICAgIHRoaXMud3JpdGVVTEVCKHZlY3Rvci5sZW5ndGgpO1xuICAgIEFycmF5LmZyb20odmVjdG9yKS5mb3JFYWNoKChlbCwgaSkgPT4gY2IodGhpcywgZWwsIGksIHZlY3Rvci5sZW5ndGgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBzdXBwb3J0IGZvciBpdGVyYXRpb25zIG92ZXIgdGhlIG9iamVjdC5cbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ5dGVQb3NpdGlvbjsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KGkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB1bmRlcmx5aW5nIGJ1ZmZlciB0YWtpbmcgb25seSB2YWx1ZSBieXRlcyAoaW4gY2FzZSBpbml0aWFsIGJ1ZmZlciBzaXplIHdhcyBiaWdnZXIpLlxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gUmVzdWx0aW5nIGJjcy5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YVZpZXcuYnVmZmVyLnNsaWNlKDAsIHRoaXMuYnl0ZVBvc2l0aW9uKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBkYXRhIGFzICdoZXgnIG9yICdiYXNlNjQnXG4gICAqIEBwYXJhbSBlbmNvZGluZyBFbmNvZGluZyB0byB1c2U6ICdiYXNlNjQnIG9yICdoZXgnXG4gICAqL1xuICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgIHJldHVybiBlbmNvZGVTdHIodGhpcy50b0J5dGVzKCksIGVuY29kaW5nKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRvTGl0dGxlRW5kaWFuKGJpZ2ludCwgc2l6ZSkge1xuICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGJpZ2ludCA+IDApIHtcbiAgICByZXN1bHRbaV0gPSBOdW1iZXIoYmlnaW50ICUgQmlnSW50KDI1NikpO1xuICAgIGJpZ2ludCA9IGJpZ2ludCAvIEJpZ0ludCgyNTYpO1xuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYmNzLXR5cGUudHNcbnZhciBfd3JpdGUsIF9zZXJpYWxpemU7XG52YXIgX0Jjc1R5cGUgPSBjbGFzcyBfQmNzVHlwZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3dyaXRlLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2VyaWFsaXplLCB2b2lkIDApO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLnJlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgdGhpcy5zZXJpYWxpemVkU2l6ZSA9IG9wdGlvbnMuc2VyaWFsaXplZFNpemUgPz8gKCgpID0+IG51bGwpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfd3JpdGUsIG9wdGlvbnMud3JpdGUpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2VyaWFsaXplLCBvcHRpb25zLnNlcmlhbGl6ZSA/PyAoKHZhbHVlLCBvcHRpb25zMikgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJjc1dyaXRlcih7IHNpemU6IHRoaXMuc2VyaWFsaXplZFNpemUodmFsdWUpID8/IHZvaWQgMCwgLi4ub3B0aW9uczIgfSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3dyaXRlKS5jYWxsKHRoaXMsIHZhbHVlLCB3cml0ZXIpO1xuICAgICAgcmV0dXJuIHdyaXRlci50b0J5dGVzKCk7XG4gICAgfSkpO1xuICAgIHRoaXMudmFsaWRhdGUgPSBvcHRpb25zLnZhbGlkYXRlID8/ICgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbiAgd3JpdGUodmFsdWUsIHdyaXRlcikge1xuICAgIHRoaXMudmFsaWRhdGUodmFsdWUpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfd3JpdGUpLmNhbGwodGhpcywgdmFsdWUsIHdyaXRlcik7XG4gIH1cbiAgc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBTZXJpYWxpemVkQmNzKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VyaWFsaXplKS5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgcGFyc2UoYnl0ZXMpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgQmNzUmVhZGVyKGJ5dGVzKTtcbiAgICByZXR1cm4gdGhpcy5yZWFkKHJlYWRlcik7XG4gIH1cbiAgdHJhbnNmb3JtKHtcbiAgICBuYW1lLFxuICAgIGlucHV0LFxuICAgIG91dHB1dFxuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBfQmNzVHlwZSh7XG4gICAgICBuYW1lOiBuYW1lID8/IHRoaXMubmFtZSxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IG91dHB1dCh0aGlzLnJlYWQocmVhZGVyKSksXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IF9fcHJpdmF0ZUdldCh0aGlzLCBfd3JpdGUpLmNhbGwodGhpcywgaW5wdXQodmFsdWUpLCB3cml0ZXIpLFxuICAgICAgc2VyaWFsaXplZFNpemU6ICh2YWx1ZSkgPT4gdGhpcy5zZXJpYWxpemVkU2l6ZShpbnB1dCh2YWx1ZSkpLFxuICAgICAgc2VyaWFsaXplOiAodmFsdWUsIG9wdGlvbnMpID0+IF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VyaWFsaXplKS5jYWxsKHRoaXMsIGlucHV0KHZhbHVlKSwgb3B0aW9ucyksXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB0aGlzLnZhbGlkYXRlKGlucHV0KHZhbHVlKSlcbiAgICB9KTtcbiAgfVxufTtcbl93cml0ZSA9IG5ldyBXZWFrTWFwKCk7XG5fc2VyaWFsaXplID0gbmV3IFdlYWtNYXAoKTtcbnZhciBCY3NUeXBlID0gX0Jjc1R5cGU7XG52YXIgU0VSSUFMSVpFRF9CQ1NfQlJBTkQgPSBTeW1ib2wuZm9yKFwiQG15c3Rlbi9zZXJpYWxpemVkLWJjc1wiKTtcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZEJjcyhvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqW1NFUklBTElaRURfQkNTX0JSQU5EXSA9PT0gdHJ1ZTtcbn1cbnZhciBfc2NoZW1hLCBfYnl0ZXM7XG52YXIgU2VyaWFsaXplZEJjcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zY2hlbWEsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ieXRlcywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NjaGVtYSwgdHlwZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9ieXRlcywgc2NoZW1hKTtcbiAgfVxuICAvLyBVc2VkIHRvIGJyYW5kIFNlcmlhbGl6ZWRCY3Mgc28gdGhhdCB0aGV5IGNhbiBiZSBpZGVudGlmaWVkLCBldmVuIGJldHdlZW4gbXVsdGlwbGUgY29waWVzXG4gIC8vIG9mIHRoZSBAbXlzdGVuL2JjcyBwYWNrYWdlIGFyZSBpbnN0YWxsZWRcbiAgZ2V0IFtTRVJJQUxJWkVEX0JDU19CUkFORF0oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9ieXRlcyk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRvSEVYKF9fcHJpdmF0ZUdldCh0aGlzLCBfYnl0ZXMpKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gdG9CNjQoX19wcml2YXRlR2V0KHRoaXMsIF9ieXRlcykpO1xuICB9XG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiB0b0I1OChfX3ByaXZhdGVHZXQodGhpcywgX2J5dGVzKSk7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2NoZW1hKS5wYXJzZShfX3ByaXZhdGVHZXQodGhpcywgX2J5dGVzKSk7XG4gIH1cbn07XG5fc2NoZW1hID0gbmV3IFdlYWtNYXAoKTtcbl9ieXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBmaXhlZFNpemVCY3NUeXBlKHtcbiAgc2l6ZSxcbiAgLi4ub3B0aW9uc1xufSkge1xuICByZXR1cm4gbmV3IEJjc1R5cGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgc2VyaWFsaXplZFNpemU6ICgpID0+IHNpemVcbiAgfSk7XG59XG5mdW5jdGlvbiB1SW50QmNzVHlwZSh7XG4gIHJlYWRNZXRob2QsXG4gIHdyaXRlTWV0aG9kLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIHJldHVybiBmaXhlZFNpemVCY3NUeXBlKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHJlYWQ6IChyZWFkZXIpID0+IHJlYWRlcltyZWFkTWV0aG9kXSgpLFxuICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4gd3JpdGVyW3dyaXRlTWV0aG9kXSh2YWx1ZSksXG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IG9wdGlvbnMubWF4VmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCAke29wdGlvbnMubmFtZX0gdmFsdWU6ICR7dmFsdWV9LiBFeHBlY3RlZCB2YWx1ZSBpbiByYW5nZSAwLSR7b3B0aW9ucy5tYXhWYWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnZhbGlkYXRlPy4odmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBiaWdVSW50QmNzVHlwZSh7XG4gIHJlYWRNZXRob2QsXG4gIHdyaXRlTWV0aG9kLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIHJldHVybiBmaXhlZFNpemVCY3NUeXBlKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHJlYWQ6IChyZWFkZXIpID0+IHJlYWRlcltyZWFkTWV0aG9kXSgpLFxuICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4gd3JpdGVyW3dyaXRlTWV0aG9kXShCaWdJbnQodmFsdWUpKSxcbiAgICB2YWxpZGF0ZTogKHZhbCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQodmFsKTtcbiAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiBvcHRpb25zLm1heFZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgJHtvcHRpb25zLm5hbWV9IHZhbHVlOiAke3ZhbHVlfS4gRXhwZWN0ZWQgdmFsdWUgaW4gcmFuZ2UgMC0ke29wdGlvbnMubWF4VmFsdWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy52YWxpZGF0ZT8uKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZHluYW1pY1NpemVCY3NUeXBlKHtcbiAgc2VyaWFsaXplLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIGNvbnN0IHR5cGUgPSBuZXcgQmNzVHlwZSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBzZXJpYWxpemUsXG4gICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgdHlwZS5zZXJpYWxpemUodmFsdWUpLnRvQnl0ZXMoKSkge1xuICAgICAgICB3cml0ZXIud3JpdGU4KGJ5dGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gc3RyaW5nTGlrZUJjc1R5cGUoe1xuICB0b0J5dGVzLFxuICBmcm9tQnl0ZXMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHJlYWQ6IChyZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVUxFQigpO1xuICAgICAgY29uc3QgYnl0ZXMgPSByZWFkZXIucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICByZXR1cm4gZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9LFxuICAgIHdyaXRlOiAoaGV4LCB3cml0ZXIpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gdG9CeXRlcyhoZXgpO1xuICAgICAgd3JpdGVyLndyaXRlVUxFQihieXRlcy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXIud3JpdGU4KGJ5dGVzW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IHRvQnl0ZXModmFsdWUpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHVsZWJFbmNvZGUoYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUubGVuZ3RoICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJlc3VsdC5zZXQoc2l6ZSwgMCk7XG4gICAgICByZXN1bHQuc2V0KGJ5dGVzLCBzaXplLmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkICR7b3B0aW9ucy5uYW1lfSB2YWx1ZTogJHt2YWx1ZX0uIEV4cGVjdGVkIHN0cmluZ2ApO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy52YWxpZGF0ZT8uKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGF6eUJjc1R5cGUoY2IpIHtcbiAgbGV0IGxhenlUeXBlID0gbnVsbDtcbiAgZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICBpZiAoIWxhenlUeXBlKSB7XG4gICAgICBsYXp5VHlwZSA9IGNiKCk7XG4gICAgfVxuICAgIHJldHVybiBsYXp5VHlwZTtcbiAgfVxuICByZXR1cm4gbmV3IEJjc1R5cGUoe1xuICAgIG5hbWU6IFwibGF6eVwiLFxuICAgIHJlYWQ6IChkYXRhKSA9PiBnZXRUeXBlKCkucmVhZChkYXRhKSxcbiAgICBzZXJpYWxpemVkU2l6ZTogKHZhbHVlKSA9PiBnZXRUeXBlKCkuc2VyaWFsaXplZFNpemUodmFsdWUpLFxuICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4gZ2V0VHlwZSgpLndyaXRlKHZhbHVlLCB3cml0ZXIpLFxuICAgIHNlcmlhbGl6ZTogKHZhbHVlLCBvcHRpb25zKSA9PiBnZXRUeXBlKCkuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zKS50b0J5dGVzKClcbiAgfSk7XG59XG5cbi8vIHNyYy9iY3MudHNcbnZhciBiY3MgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy51OCgpLnNlcmlhbGl6ZSgyNTUpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMjU1IF1cbiAgICovXG4gIHU4KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1OFwiLFxuICAgICAgcmVhZE1ldGhvZDogXCJyZWFkOFwiLFxuICAgICAgd3JpdGVNZXRob2Q6IFwid3JpdGU4XCIsXG4gICAgICBzaXplOiAxLFxuICAgICAgbWF4VmFsdWU6IDIgKiogOCAtIDEsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy51MTYoKS5zZXJpYWxpemUoNjU1MzUpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMjU1LCAyNTUgXVxuICAgKi9cbiAgdTE2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1MTZcIixcbiAgICAgIHJlYWRNZXRob2Q6IFwicmVhZDE2XCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZTE2XCIsXG4gICAgICBzaXplOiAyLFxuICAgICAgbWF4VmFsdWU6IDIgKiogMTYgLSAxLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MudTMyKCkuc2VyaWFsaXplKDQyOTQ5NjcyOTUpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMjU1LCAyNTUsIDI1NSwgMjU1IF1cbiAgICovXG4gIHUzMihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHVJbnRCY3NUeXBlKHtcbiAgICAgIG5hbWU6IFwidTMyXCIsXG4gICAgICByZWFkTWV0aG9kOiBcInJlYWQzMlwiLFxuICAgICAgd3JpdGVNZXRob2Q6IFwid3JpdGUzMlwiLFxuICAgICAgc2l6ZTogNCxcbiAgICAgIG1heFZhbHVlOiAyICoqIDMyIC0gMSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVhZCBhbmQgd3JpdGUgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnU2NCgpLnNlcmlhbGl6ZSgxKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXVxuICAgKi9cbiAgdTY0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYmlnVUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1NjRcIixcbiAgICAgIHJlYWRNZXRob2Q6IFwicmVhZDY0XCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZTY0XCIsXG4gICAgICBzaXplOiA4LFxuICAgICAgbWF4VmFsdWU6IDJuICoqIDY0biAtIDFuLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSBhIDEyOC1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnUxMjgoKS5zZXJpYWxpemUoMSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAuLi4sIDAgXVxuICAgKi9cbiAgdTEyOChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJpZ1VJbnRCY3NUeXBlKHtcbiAgICAgIG5hbWU6IFwidTEyOFwiLFxuICAgICAgcmVhZE1ldGhvZDogXCJyZWFkMTI4XCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZTEyOFwiLFxuICAgICAgc2l6ZTogMTYsXG4gICAgICBtYXhWYWx1ZTogMm4gKiogMTI4biAtIDFuLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSBhIDI1Ni1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnUyNTYoKS5zZXJpYWxpemUoMSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAuLi4sIDAgXVxuICAgKi9cbiAgdTI1NihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJpZ1VJbnRCY3NUeXBlKHtcbiAgICAgIG5hbWU6IFwidTI1NlwiLFxuICAgICAgcmVhZE1ldGhvZDogXCJyZWFkMjU2XCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZTI1NlwiLFxuICAgICAgc2l6ZTogMzIsXG4gICAgICBtYXhWYWx1ZTogMm4gKiogMjU2biAtIDFuLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSBib29sZWFuIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLmJvb2woKS5zZXJpYWxpemUodHJ1ZSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxIF1cbiAgICovXG4gIGJvb2wob3B0aW9ucykge1xuICAgIHJldHVybiBmaXhlZFNpemVCY3NUeXBlKHtcbiAgICAgIG5hbWU6IFwiYm9vbFwiLFxuICAgICAgc2l6ZTogMSxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHJlYWRlci5yZWFkOCgpID09PSAxLFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB3cml0ZXIud3JpdGU4KHZhbHVlID8gMSA6IDApLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgZm91bmQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVhZCBhbmQgd3JpdGUgdW5zaWduZWQgTEVCIGVuY29kZWQgaW50ZWdlcnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICovXG4gIHVsZWIxMjgob3B0aW9ucykge1xuICAgIHJldHVybiBkeW5hbWljU2l6ZUJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1bGViMTI4XCIsXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiByZWFkZXIucmVhZFVMRUIoKSxcbiAgICAgIHNlcmlhbGl6ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odWxlYkVuY29kZSh2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhIGZpeGVkIGxlbmd0aCBieXRlIGFycmF5XG4gICAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhpcyB0eXBlcyByZXByZXNlbnRzXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy5ieXRlcygzKS5zZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWzEsIDIsIDNdXG4gICAqL1xuICBieXRlcyhzaXplLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZpeGVkU2l6ZUJjc1R5cGUoe1xuICAgICAgbmFtZTogYGJ5dGVzWyR7c2l6ZX1dYCxcbiAgICAgIHNpemUsXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiByZWFkZXIucmVhZEJ5dGVzKHNpemUpLFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlOCh2YWx1ZVtpXSA/PyAwKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAoIShcImxlbmd0aFwiIGluIHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGFycmF5LCBmb3VuZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXkgb2YgbGVuZ3RoICR7c2l6ZX0sIGZvdW5kICR7dmFsdWUubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBzZXIvZGUgc3RyaW5nIHZhbHVlcy4gIFN0cmluZ3Mgd2lsbCBiZSBVVEYtOCBlbmNvZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy5zdHJpbmcoKS5zZXJpYWxpemUoJ2EnKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDk3IF1cbiAgICovXG4gIHN0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0cmluZ0xpa2VCY3NUeXBlKHtcbiAgICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgICB0b0J5dGVzOiAodmFsdWUpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSksXG4gICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgcmVwcmVzZW50cyBhIGZpeGVkIGxlbmd0aCBhcnJheSBvZiBhIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIHNpemUgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICogQHBhcmFtIHR5cGUgVGhlIEJjc1R5cGUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MuZml4ZWRBcnJheSgzLCBiY3MudTgoKSkuc2VyaWFsaXplKFsxLCAyLCAzXSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAgICovXG4gIGZpeGVkQXJyYXkoc2l6ZSwgdHlwZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgICBuYW1lOiBgJHt0eXBlLm5hbWV9WyR7c2l6ZX1dYCxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHR5cGUucmVhZChyZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHR5cGUud3JpdGUoaXRlbSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAoIShcImxlbmd0aFwiIGluIHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGFycmF5LCBmb3VuZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXkgb2YgbGVuZ3RoICR7c2l6ZX0sIGZvdW5kICR7dmFsdWUubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSByZXByZXNlbnRpbmcgYW4gb3B0aW9uYWwgdmFsdWVcbiAgICogQHBhcmFtIHR5cGUgVGhlIEJjc1R5cGUgb2YgdGhlIG9wdGlvbmFsIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy5vcHRpb24oYmNzLnU4KCkpLnNlcmlhbGl6ZShudWxsKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDAgXVxuICAgKiBiY3Mub3B0aW9uKGJjcy51OCgpKS5zZXJpYWxpemUoMSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAxIF1cbiAgICovXG4gIG9wdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIGJjcy5lbnVtKGBPcHRpb248JHt0eXBlLm5hbWV9PmAsIHtcbiAgICAgIE5vbmU6IG51bGwsXG4gICAgICBTb21lOiB0eXBlXG4gICAgfSkudHJhbnNmb3JtKHtcbiAgICAgIGlucHV0OiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4geyBOb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgU29tZTogdmFsdWUgfTtcbiAgICAgIH0sXG4gICAgICBvdXRwdXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoXCJTb21lXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuU29tZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhIHZhcmlhYmxlIGxlbmd0aCB2ZWN0b3Igb2YgYSBnaXZlbiB0eXBlXG4gICAqIEBwYXJhbSB0eXBlIFRoZSBCY3NUeXBlIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgdmVjdG9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy52ZWN0b3IoYmNzLnU4KCkpLnRvQnl0ZXMoWzEsIDIsIDNdKSAvLyBVaW50OEFycmF5IFsgMywgMSwgMiwgMyBdXG4gICAqL1xuICB2ZWN0b3IodHlwZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgICBuYW1lOiBgdmVjdG9yPCR7dHlwZS5uYW1lfT5gLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkZXIucmVhZFVMRUIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSB0eXBlLnJlYWQocmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4ge1xuICAgICAgICB3cml0ZXIud3JpdGVVTEVCKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHR5cGUud3JpdGUoaXRlbSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAoIShcImxlbmd0aFwiIGluIHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGFycmF5LCBmb3VuZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgcmVwcmVzZW50aW5nIGEgdHVwbGUgb2YgYSBnaXZlbiBzZXQgb2YgdHlwZXNcbiAgICogQHBhcmFtIHR5cGVzIFRoZSBCY3NUeXBlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSB0dXBsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB0dXBsZSA9IGJjcy50dXBsZShbYmNzLnU4KCksIGJjcy5zdHJpbmcoKSwgYmNzLmJvb2woKV0pXG4gICAqIHR1cGxlLnNlcmlhbGl6ZShbMSwgJ2EnLCB0cnVlXSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAxLCA5NywgMSBdXG4gICAqL1xuICB0dXBsZSh0eXBlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgICBuYW1lOiBgKCR7dHlwZXMubWFwKCh0KSA9PiB0Lm5hbWUpLmpvaW4oXCIsIFwiKX0pYCxcbiAgICAgIHNlcmlhbGl6ZWRTaXplOiAodmFsdWVzKSA9PiB7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gdHlwZXNbaV0uc2VyaWFsaXplZFNpemUodmFsdWVzW2ldKTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWwgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9LFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godHlwZS5yZWFkKHJlYWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0eXBlc1tpXS53cml0ZSh2YWx1ZVtpXSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXksIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGFycmF5IG9mIGxlbmd0aCAke3R5cGVzLmxlbmd0aH0sIGZvdW5kICR7dmFsdWUubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSByZXByZXNlbnRpbmcgYSBzdHJ1Y3Qgb2YgYSBnaXZlbiBzZXQgb2YgZmllbGRzXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzdHJ1Y3RcbiAgICogQHBhcmFtIGZpZWxkcyBUaGUgZmllbGRzIG9mIHRoZSBzdHJ1Y3QuIFRoZSBvcmRlciBvZiB0aGUgZmllbGRzIGFmZmVjdHMgaG93IGRhdGEgaXMgc2VyaWFsaXplZCBhbmQgZGVzZXJpYWxpemVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHN0cnVjdCA9IGJjcy5zdHJ1Y3QoJ015U3RydWN0Jywge1xuICAgKiAgYTogYmNzLnU4KCksXG4gICAqICBiOiBiY3Muc3RyaW5nKCksXG4gICAqIH0pXG4gICAqIHN0cnVjdC5zZXJpYWxpemUoeyBhOiAxLCBiOiAnYScgfSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAxLCA5NyBdXG4gICAqL1xuICBzdHJ1Y3QobmFtZSwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2Fub25pY2FsT3JkZXIgPSBPYmplY3QuZW50cmllcyhmaWVsZHMpO1xuICAgIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgICBuYW1lLFxuICAgICAgc2VyaWFsaXplZFNpemU6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbZmllbGQsIHR5cGVdIG9mIGNhbm9uaWNhbE9yZGVyKSB7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IHR5cGUuc2VyaWFsaXplZFNpemUodmFsdWVzW2ZpZWxkXSk7XG4gICAgICAgICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB0eXBlXSBvZiBjYW5vbmljYWxPcmRlcikge1xuICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSB0eXBlLnJlYWQocmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZCwgdHlwZV0gb2YgY2Fub25pY2FsT3JkZXIpIHtcbiAgICAgICAgICB0eXBlLndyaXRlKHZhbHVlW2ZpZWxkXSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBvYmplY3QsIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSByZXByZXNlbnRpbmcgYW4gZW51bSBvZiBhIGdpdmVuIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBlbnVtXG4gICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlcyBvZiB0aGUgZW51bS4gVGhlIG9yZGVyIG9mIHRoZSB2YWx1ZXMgYWZmZWN0cyBob3cgZGF0YSBpcyBzZXJpYWxpemVkIGFuZCBkZXNlcmlhbGl6ZWQuXG4gICAqIG51bGwgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGEgdmFyaWFudCB3aXRoIG5vIGRhdGEuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGVudW0gPSBiY3MuZW51bSgnTXlFbnVtJywge1xuICAgKiAgIEE6IGJjcy51OCgpLFxuICAgKiAgIEI6IGJjcy5zdHJpbmcoKSxcbiAgICogICBDOiBudWxsLFxuICAgKiB9KVxuICAgKiBlbnVtLnNlcmlhbGl6ZSh7IEE6IDEgfSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAwLCAxIF1cbiAgICogZW51bS5zZXJpYWxpemUoeyBCOiAnYScgfSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAxLCAxLCA5NyBdXG4gICAqIGVudW0uc2VyaWFsaXplKHsgQzogdHJ1ZSB9KS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDIgXVxuICAgKi9cbiAgZW51bShuYW1lLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYW5vbmljYWxPcmRlciA9IE9iamVjdC5lbnRyaWVzKHZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAgIG5hbWUsXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVhZGVyLnJlYWRVTEVCKCk7XG4gICAgICAgIGNvbnN0IFtuYW1lMiwgdHlwZV0gPSBjYW5vbmljYWxPcmRlcltpbmRleF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW25hbWUyXTogdHlwZT8ucmVhZChyZWFkZXIpID8/IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgW25hbWUyLCB2YWxdID0gT2JqZWN0LmVudHJpZXModmFsdWUpWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbm9uaWNhbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgW29wdGlvbk5hbWUsIG9wdGlvblR5cGVdID0gY2Fub25pY2FsT3JkZXJbaV07XG4gICAgICAgICAgaWYgKG9wdGlvbk5hbWUgPT09IG5hbWUyKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVVTEVCKGkpO1xuICAgICAgICAgICAgb3B0aW9uVHlwZT8ud3JpdGUodmFsLCB3cml0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIG9wdGlvbnM/LnZhbGlkYXRlPy4odmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBvYmplY3QsIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIG9iamVjdCB3aXRoIG9uZSBrZXksIGZvdW5kICR7a2V5cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW25hbWUyXSA9IGtleXM7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bih2YWx1ZXMsIG5hbWUyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZW51bSB2YXJpYW50ICR7bmFtZTJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhIG1hcCBvZiBhIGdpdmVuIGtleSBhbmQgdmFsdWUgdHlwZVxuICAgKiBAcGFyYW0ga2V5VHlwZSBUaGUgQmNzVHlwZSBvZiB0aGUga2V5XG4gICAqIEBwYXJhbSB2YWx1ZVR5cGUgVGhlIEJjc1R5cGUgb2YgdGhlIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1hcCA9IGJjcy5tYXAoYmNzLnU4KCksIGJjcy5zdHJpbmcoKSlcbiAgICogbWFwLnNlcmlhbGl6ZShuZXcgTWFwKFtbMiwgJ2EnXV0pKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDIsIDEsIDk3IF1cbiAgICovXG4gIG1hcChrZXlUeXBlLCB2YWx1ZVR5cGUpIHtcbiAgICByZXR1cm4gYmNzLnZlY3RvcihiY3MudHVwbGUoW2tleVR5cGUsIHZhbHVlVHlwZV0pKS50cmFuc2Zvcm0oe1xuICAgICAgbmFtZTogYE1hcDwke2tleVR5cGUubmFtZX0sICR7dmFsdWVUeXBlLm5hbWV9PmAsXG4gICAgICBpbnB1dDogKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWUuZW50cmllcygpXTtcbiAgICAgIH0sXG4gICAgICBvdXRwdXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICpcbiAgICogR2VuZXJpY3Mgc2hvdWxkIGJlIGltcGxlbWVudGVkIGFzIGdlbmVyaWMgdHlwZXNjcmlwdCBmdW5jdGlvbnMgaW5zdGVhZDpcbiAgICpcbiAgICogYGBgdHNcbiAgICogZnVuY3Rpb24gVmVjTWFwPEssIFY+LCAoSzogQmNzVHlwZTxLPiwgVjogQmNzVHlwZTxWPikge1xuICAgKiAgIHJldHVybiBiY3Muc3RydWN0KCdWZWNNYXA8SywgVj4nLCB7XG4gICAqICAgICBrZXlzOiBiY3MudmVjdG9yKEspLFxuICAgKiAgICAgdmFsdWVzOiBiY3MudmVjdG9yKFYpLFxuICAgKiAgIH0pXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBnZW5lcmljKG5hbWVzLCBjYikge1xuICAgIHJldHVybiAoLi4udHlwZXMpID0+IHtcbiAgICAgIHJldHVybiBjYiguLi50eXBlcykudHJhbnNmb3JtKHtcbiAgICAgICAgbmFtZTogYCR7Y2IubmFtZX08JHt0eXBlcy5tYXAoKHQpID0+IHQubmFtZSkuam9pbihcIiwgXCIpfT5gLFxuICAgICAgICBpbnB1dDogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgICAgb3V0cHV0OiAodmFsdWUpID0+IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCB3cmFwcyBhbm90aGVyIEJjc1R5cGUgd2hpY2ggaXMgbGF6aWx5IGV2YWx1YXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIHJlY3Vyc2l2ZSB0eXBlcy5cbiAgICogQHBhcmFtIGNiIEEgY2FsbGJhY2sgdGhhdCByZXR1cm5zIHRoZSBCY3NUeXBlXG4gICAqL1xuICBsYXp5KGNiKSB7XG4gICAgcmV0dXJuIGxhenlCY3NUeXBlKGNiKTtcbiAgfVxufTtcblxuLy8gc3JjL2xlZ2FjeS1yZWdpc3RyeS50c1xudmFyIFNVSV9BRERSRVNTX0xFTkdUSCA9IDMyO1xudmFyIF9CQ1MgPSBjbGFzcyBfQkNTIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEJDUyBpbnN0YW5jZSB3aXRoIGEgcHJlcGFyZWQgc2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIEEgcHJlcGFyZWQgc2NoZW1hIHdpdGggdHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0gd2l0aFByaW1pdGl2ZXMgV2hldGhlciB0byByZWdpc3RlciBwcmltaXRpdmUgdHlwZXMgYnkgZGVmYXVsdFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgLyoqXG4gICAgICogTWFwIG9mIGtpbmQgYFR5cGVOYW1lID0+IFR5cGVJbnRlcmZhY2VgLiBIb2xkcyBhbGxcbiAgICAgKiBjYWxsYmFja3MgZm9yIChkZSlzZXJpYWxpemF0aW9uIG9mIGV2ZXJ5IHJlZ2lzdGVyZWQgdHlwZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBzdG9yZWQgaXMgYSBzdHJpbmcsIGl0IGlzIHRyZWF0ZWQgYXMgYW4gYWxpYXMuXG4gICAgICovXG4gICAgdGhpcy50eXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQ291bnQgdGVtcCBrZXlzIHRvIGdlbmVyYXRlIGEgbmV3IG9uZSB3aGVuIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBfQkNTKSB7XG4gICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYS5zY2hlbWE7XG4gICAgICB0aGlzLnR5cGVzID0gbmV3IE1hcChzY2hlbWEudHlwZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLnJlZ2lzdGVyQWRkcmVzc1R5cGUoX0JDUy5BRERSRVNTLCBzY2hlbWEuYWRkcmVzc0xlbmd0aCwgc2NoZW1hLmFkZHJlc3NFbmNvZGluZyk7XG4gICAgdGhpcy5yZWdpc3RlclZlY3RvclR5cGUoc2NoZW1hLnZlY3RvclR5cGUpO1xuICAgIGlmIChzY2hlbWEudHlwZXMgJiYgc2NoZW1hLnR5cGVzLnN0cnVjdHMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnR5cGVzLnN0cnVjdHMpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTdHJ1Y3RUeXBlKG5hbWUsIHNjaGVtYS50eXBlcy5zdHJ1Y3RzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS50eXBlcyAmJiBzY2hlbWEudHlwZXMuZW51bXMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnR5cGVzLmVudW1zKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRW51bVR5cGUobmFtZSwgc2NoZW1hLnR5cGVzLmVudW1zW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS50eXBlcyAmJiBzY2hlbWEudHlwZXMuYWxpYXNlcykge1xuICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyhzY2hlbWEudHlwZXMuYWxpYXNlcykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckFsaWFzKG5hbWUsIHNjaGVtYS50eXBlcy5hbGlhc2VzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS53aXRoUHJpbWl0aXZlcyAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZ2lzdGVyUHJpbWl0aXZlcyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGtleSB0byB1c2UgZm9yIHRlbXBvcmFyeSBzdHJ1Y3QgZGVmaW5pdGlvbnMuXG4gICAqIFJldHVybnMgYSB0ZW1wIGtleSArIGluZGV4IChmb3IgYSBjYXNlIHdoZW4gbXVsdGlwbGUgdGVtcFxuICAgKiBzdHJ1Y3RzIGFyZSBwcm9jZXNzZWQpLlxuICAgKi9cbiAgdGVtcEtleSgpIHtcbiAgICByZXR1cm4gYGJjcy1zdHJ1Y3QtJHsrK3RoaXMuY291bnRlcn1gO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgZGF0YSBpbnRvIGJjcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnJlZ2lzdGVyVmVjdG9yVHlwZSgndmVjdG9yPHU4PicsICd1OCcpO1xuICAgKlxuICAgKiBsZXQgc2VyaWFsaXplZCA9IEJDU1xuICAgKiAgIC5zZXQoJ3ZlY3Rvcjx1OD4nLCBbMSwyLDMsNCw1LDZdKVxuICAgKiAgIC50b0J5dGVzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KHRvSGV4KHNlcmlhbGl6ZWQpID09PSAnMDYwMTAyMDMwNDA1MDYnKTtcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgTmFtZSBvZiB0aGUgdHlwZSB0byBzZXJpYWxpemUgKG11c3QgYmUgcmVnaXN0ZXJlZCkgb3IgYSBzdHJ1Y3QgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBzZXJpYWxpemUuXG4gICAqIEBwYXJhbSBzaXplIFNlcmlhbGl6YXRpb24gYnVmZmVyIHNpemUuIERlZmF1bHQgMTAyNCA9IDFLQi5cbiAgICogQHJldHVybiBBIEJDUyByZWFkZXIgaW5zdGFuY2UuIFVzdWFsbHkgeW91J2Qgd2FudCB0byBjYWxsIGAudG9CeXRlcygpYFxuICAgKi9cbiAgc2VyKHR5cGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSkuZW5jb2RlKHRoaXMsIGRhdGEsIG9wdGlvbnMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy50ZW1wS2V5KCk7XG4gICAgICBjb25zdCB0ZW1wID0gbmV3IF9CQ1ModGhpcyk7XG4gICAgICByZXR1cm4gdGVtcC5yZWdpc3RlclN0cnVjdFR5cGUoa2V5LCB0eXBlKS5zZXIoa2V5LCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgdHlwZSBwYXNzZWQgaW50byB0aGUgJy5zZXIoKScgZnVuY3Rpb24uIFxuJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgQkNTIGludG8gYSBKUyB0eXBlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgbnVtID0gYmNzLnNlcigndTY0JywgJzQyOTQ5NjcyOTUnKS50b1N0cmluZygnaGV4Jyk7XG4gICAqIGxldCBkZU51bSA9IGJjcy5kZSgndTY0JywgbnVtLCAnaGV4Jyk7XG4gICAqIGNvbnNvbGUuYXNzZXJ0KGRlTnVtLnRvU3RyaW5nKDEwKSA9PT0gJzQyOTQ5NjcyOTUnKTtcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgTmFtZSBvZiB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZSAobXVzdCBiZSByZWdpc3RlcmVkKSBvciBhIHN0cnVjdCB0eXBlIGRlZmluaXRpb24uXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gZGVzZXJpYWxpemUuXG4gICAqIEBwYXJhbSBlbmNvZGluZyBPcHRpb25hbCAtIGVuY29kaW5nIHRvIHVzZSBpZiBkYXRhIGlzIG9mIHR5cGUgU3RyaW5nXG4gICAqIEByZXR1cm4gRGVzZXJpYWxpemVkIGRhdGEuXG4gICAqL1xuICBkZSh0eXBlLCBkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIGRhdGEgPSBkZWNvZGVTdHIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gcGFzcyBhIHN0cmluZyB0byBgYmNzLmRlYCwgc3BlY2lmeSBlbmNvZGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUpLmRlY29kZSh0aGlzLCBkYXRhLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBuZXcgX0JDUyh0aGlzKTtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudGVtcEtleSgpO1xuICAgICAgcmV0dXJuIHRlbXAucmVnaXN0ZXJTdHJ1Y3RUeXBlKGtleSwgdHlwZSkuZGUoa2V5LCBkYXRhLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IHR5cGUgcGFzc2VkIGludG8gdGhlICcuZGUoKScgZnVuY3Rpb24uIFxuJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIGBUeXBlSW50ZXJmYWNlYCBoYXMgYmVlbiBsb2FkZWQgZm9yIGEgYHR5cGVgLlxuICAgKiBAcGFyYW0gdHlwZSBOYW1lIG9mIHRoZSB0eXBlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZXMuaGFzKHR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYWxpYXMgZm9yIGEgdHlwZS5cbiAgICogV0FSTklORzogdGhpcyBjYW4gcG90ZW50aWFsbHkgbGVhZCB0byByZWN1cnNpb25cbiAgICogQHBhcmFtIG5hbWUgQWxpYXMgdG8gdXNlXG4gICAqIEBwYXJhbSBmb3JUeXBlIFR5cGUgdG8gcmVmZXJlbmNlXG4gICAqIEByZXR1cm5zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBsZXQgYmNzID0gbmV3IEJDUyhnZXRTdWlNb3ZlQ29uZmlnKCkpO1xuICAgKiBiY3MucmVnaXN0ZXJBbGlhcygnT2JqZWN0RGlnZXN0JywgQkNTLkJBU0U1OCk7XG4gICAqIGxldCBiNThfZGlnZXN0ID0gYmNzLmRlKCdPYmplY3REaWdlc3QnLCAnPGRpZ2VzdF9ieXRlcz4nLCAnYmFzZTY0Jyk7XG4gICAqIGBgYFxuICAgKi9cbiAgcmVnaXN0ZXJBbGlhcyhuYW1lLCBmb3JUeXBlKSB7XG4gICAgdGhpcy50eXBlcy5zZXQobmFtZSwgZm9yVHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0byByZWdpc3RlciBuZXcgdHlwZXMgZm9yIEJDUyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cbiAgICogRm9yIGVhY2ggcmVnaXN0ZXJlZCB0eXBlIDIgY2FsbGJhY2tzIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBvbmUgaXMgb3B0aW9uYWw6XG4gICAqXG4gICAqIC0gZW5jb2RlQ2Iod3JpdGVyLCBkYXRhKSAtIHdyaXRlIGEgd2F5IHRvIHNlcmlhbGl6ZSBkYXRhIHdpdGggQmNzV3JpdGVyO1xuICAgKiAtIGRlY29kZUNiKHJlYWRlcikgLSB3cml0ZSBhIHdheSB0byBkZXNlcmlhbGl6ZSBkYXRhIHdpdGggQmNzUmVhZGVyO1xuICAgKiAtIHZhbGlkYXRlQ2IoZGF0YSkgLSB2YWxpZGF0ZSBkYXRhIC0gZWl0aGVyIHJldHVybiBib29sIG9yIHRocm93IGFuIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIG91ciB0eXBlIHdvdWxkIGJlIGEgc3RyaW5nIHRoYXQgY29uc2lzdHMgb25seSBvZiBudW1iZXJzXG4gICAqIGJjcy5yZWdpc3RlclR5cGUoJ251bWJlcl9zdHJpbmcnLFxuICAgKiAgICAod3JpdGVyLCBkYXRhKSA9PiB3cml0ZXIud3JpdGVWZWMoZGF0YSwgKHcsIGVsKSA9PiB3LndyaXRlOChlbCkpLFxuICAgKiAgICAocmVhZGVyKSA9PiByZWFkZXIucmVhZFZlYygocikgPT4gci5yZWFkOCgpKS5qb2luKCcnKSwgLy8gcmVhZCBlYWNoIHZhbHVlIGFzIHU4XG4gICAqICAgICh2YWx1ZSkgPT4gL1swLTldKy8udGVzdCh2YWx1ZSkgLy8gdGVzdCB0aGF0IGl0IGhhcyBhdCBsZWFzdCBvbmUgZGlnaXRcbiAgICogKTtcbiAgICogY29uc29sZS5sb2coQXJyYXkuZnJvbShiY3Muc2VyKCdudW1iZXJfc3RyaW5nJywgJzEyMzQ1JykudG9CeXRlcygpKSA9PSBbNSwxLDIsMyw0LDVdKTtcbiAgICpcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIGVuY29kZUNiIENhbGxiYWNrIHRvIGVuY29kZSBhIHZhbHVlLlxuICAgKiBAcGFyYW0gZGVjb2RlQ2IgQ2FsbGJhY2sgdG8gZGVjb2RlIGEgdmFsdWUuXG4gICAqIEBwYXJhbSB2YWxpZGF0ZUNiIE9wdGlvbmFsIHZhbGlkYXRvciBDYWxsYmFjayB0byBjaGVjayB0eXBlIGJlZm9yZSBzZXJpYWxpemF0aW9uLlxuICAgKi9cbiAgcmVnaXN0ZXJUeXBlKHR5cGVOYW1lLCBlbmNvZGVDYiwgZGVjb2RlQ2IsIHZhbGlkYXRlQ2IgPSAoKSA9PiB0cnVlKSB7XG4gICAgY29uc3QgeyBuYW1lLCBwYXJhbXM6IGdlbmVyaWNzIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU5hbWUpO1xuICAgIHRoaXMudHlwZXMuc2V0KG5hbWUsIHtcbiAgICAgIGVuY29kZShzZWxmLCBkYXRhLCBvcHRpb25zLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHR5cGVNYXAgPSBnZW5lcmljcy5yZWR1Y2UoKGFjYywgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7IFt2YWx1ZV06IHR5cGVQYXJhbXNbaW5kZXhdIH0pO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVSYXcuY2FsbChzZWxmLCBuZXcgQmNzV3JpdGVyKG9wdGlvbnMpLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKTtcbiAgICAgIH0sXG4gICAgICBkZWNvZGUoc2VsZiwgZGF0YSwgdHlwZVBhcmFtcykge1xuICAgICAgICBjb25zdCB0eXBlTWFwID0gZ2VuZXJpY3MucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbdmFsdWVdOiB0eXBlUGFyYW1zW2luZGV4XSB9KTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUmF3LmNhbGwoc2VsZiwgbmV3IEJjc1JlYWRlcihkYXRhKSwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG4gICAgICB9LFxuICAgICAgLy8gdGhlc2UgbWV0aG9kcyBzaG91bGQgYWx3YXlzIGJlIHVzZWQgd2l0aCBjYXV0aW9uIGFzIHRoZXkgcmVxdWlyZSBwcmUtZGVmaW5lZFxuICAgICAgLy8gcmVhZGVyIGFuZCB3cml0ZXIgYW5kIG1haW5seSBleGlzdCB0byBhbGxvdyBtdWx0aS1maWVsZCAoZGUpc2VyaWFsaXphdGlvbjtcbiAgICAgIF9lbmNvZGVSYXcod3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZUNiKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZUNiLmNhbGwodGhpcywgd3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRpb24gZmFpbGVkIGZvciB0eXBlICR7bmFtZX0sIGRhdGE6ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9kZWNvZGVSYXcocmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVDYi5jYWxsKHRoaXMsIHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gIFx0ICogTWV0aG9kIHRvIHJlZ2lzdGVyIEJjc1R5cGUgaW5zdGFuY2VzIHRvIHRoZSByZWdpc3RyeVxuICBcdCAqIFR5cGVzIGFyZSByZWdpc3RlcmVkIHdpdGggYSBjYWxsYmFjayB0aGF0IHByb3ZpZGVzIEJjc1R5cGUgaW5zdGFuY2VzIGZvciBlYWNoIGdlbmVyaWNcbiAgXHQgKiBwYXNzZWQgdG8gdGhlIHR5cGUuXG4gIFx0ICpcbiAgXHQgKiAtIGNyZWF0ZVR5cGUoLi4uZ2VuZXJpY3MpIC0gUmV0dXJuIGEgQmNzVHlwZSBpbnN0YW5jZVxuICBcdCAqXG4gIFx0ICogQGV4YW1wbGVcbiAgXHQgKiAvLyBvdXIgdHlwZSB3b3VsZCBiZSBhIHN0cmluZyB0aGF0IGNvbnNpc3RzIG9ubHkgb2YgbnVtYmVyc1xuICBcdCAqIGJjcy5yZWdpc3RlclR5cGUoJ0JveDxUPicsIChUKSA9PiB7XG4gIFx0ICogXHRcdHJldHVybiBiY3Muc3RydWN0KHtcbiAgXHQgKiBcdFx0XHR2YWx1ZTogVFxuICBcdCAqIFx0XHR9KTtcbiAgXHQgKiB9KTtcbiAgXG4gIFx0ICogY29uc29sZS5sb2coQXJyYXkuZnJvbShiY3Muc2VyKCdCb3g8c3RyaW5nPicsICcxMjM0NScpLnRvQnl0ZXMoKSkgPT0gWzUsMSwyLDMsNCw1XSk7XG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0gbmFtZVxuICBcdCAqIEBwYXJhbSBjcmVhdGVUeXBlIGEgQ2FsbGJhY2sgdG8gY3JlYXRlIHRoZSBCY3NUeXBlIHdpdGggYW55IHBhc3NlZCBpbiBnZW5lcmljc1xuICBcdCAqL1xuICByZWdpc3RlckJjc1R5cGUodHlwZU5hbWUsIGNyZWF0ZVR5cGUpIHtcbiAgICB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgIHR5cGVOYW1lLFxuICAgICAgKHdyaXRlciwgZGF0YSwgdHlwZVBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBnZW5lcmljcyA9IHR5cGVQYXJhbXMubWFwKFxuICAgICAgICAgIChwYXJhbSkgPT4gbmV3IEJjc1R5cGUoe1xuICAgICAgICAgICAgbmFtZTogU3RyaW5nKHBhcmFtKSxcbiAgICAgICAgICAgIHdyaXRlOiAoZGF0YTIsIHdyaXRlcjIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShwYXJhbSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVJbnRlcmZhY2UgPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVNYXAgPSBwYXJhbXMucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbdmFsdWVdOiB0eXBlUGFyYW1zW2luZGV4XSB9KTtcbiAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZUludGVyZmFjZS5fZW5jb2RlUmF3LmNhbGwodGhpcywgd3JpdGVyMiwgZGF0YTIsIHBhcmFtcywgdHlwZU1hcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3JlYXRlVHlwZSguLi5nZW5lcmljcykud3JpdGUoZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH0sXG4gICAgICAocmVhZGVyLCB0eXBlUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGdlbmVyaWNzID0gdHlwZVBhcmFtcy5tYXAoXG4gICAgICAgICAgKHBhcmFtKSA9PiBuZXcgQmNzVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiBTdHJpbmcocGFyYW0pLFxuICAgICAgICAgICAgd3JpdGU6IChkYXRhLCB3cml0ZXIpID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWQ6IChyZWFkZXIyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUocGFyYW0pO1xuICAgICAgICAgICAgICBjb25zdCB0eXBlSW50ZXJmYWNlID0gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUpO1xuICAgICAgICAgICAgICBjb25zdCB0eXBlTWFwID0gcGFyYW1zLnJlZHVjZSgoYWNjLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW3ZhbHVlXTogdHlwZVBhcmFtc1tpbmRleF0gfSk7XG4gICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVJbnRlcmZhY2UuX2RlY29kZVJhdy5jYWxsKHRoaXMsIHJlYWRlcjIsIHBhcmFtcywgdHlwZU1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVR5cGUoLi4uZ2VuZXJpY3MpLnJlYWQocmVhZGVyKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBhZGRyZXNzIHR5cGUgd2hpY2ggaXMgYSBzZXF1ZW5jZSBvZiBVOHMgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnJlZ2lzdGVyQWRkcmVzc1R5cGUoJ2FkZHJlc3MnLCBTVUlfQUREUkVTU19MRU5HVEgpO1xuICAgKiBsZXQgYWRkciA9IGJjcy5kZSgnYWRkcmVzcycsICdjM2FjYTUxMGM3ODVjNzA5NGFjOTlhZWFhMWU2OWQ0OTMxMjI0NDRkZjUwYmI4YTk5ZGZhNzkwYzY1NGE3OWFmJyk7XG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGFkZHJlc3MgdHlwZS5cbiAgICogQHBhcmFtIGxlbmd0aCBCeXRlIGxlbmd0aCBvZiB0aGUgYWRkcmVzcy5cbiAgICogQHBhcmFtIGVuY29kaW5nIEVuY29kaW5nIHRvIHVzZSBmb3IgdGhlIGFkZHJlc3MgdHlwZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVnaXN0ZXJBZGRyZXNzVHlwZShuYW1lLCBsZW5ndGgsIGVuY29kaW5nID0gXCJoZXhcIikge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJUeXBlKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZnVuY3Rpb24gZW5jb2RlQWRkcmVzcyh3cml0ZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQjY0KGRhdGEpLnJlZHVjZSgod3JpdGVyMiwgZWwpID0+IHdyaXRlcjIud3JpdGU4KGVsKSwgd3JpdGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MocmVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9CNjQocmVhZGVyLnJlYWRCeXRlcyhsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZUFkZHJlc3Mod3JpdGVyLCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUhFWChkYXRhKS5yZWR1Y2UoKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbCksIHdyaXRlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiBkZWNvZGVBZGRyZXNzKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRvSEVYKHJlYWRlci5yZWFkQnl0ZXMobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2RpbmchIFVzZSBlaXRoZXIgaGV4IG9yIGJhc2U2NFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGN1c3RvbSB2ZWN0b3IgdHlwZSBpbnNpZGUgdGhlIGJjcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnJlZ2lzdGVyVmVjdG9yVHlwZSgndmVjdG9yPFQ+Jyk7IC8vIGdlbmVyaWMgcmVnaXN0cmF0aW9uXG4gICAqIGxldCBhcnJheSA9IGJjcy5kZSgndmVjdG9yPHU4PicsICcwNjAxMDIwMzA0MDUwNicsICdoZXgnKTsgLy8gWzEsMiwzLDQsNSw2XTtcbiAgICogbGV0IGFnYWluID0gYmNzLnNlcigndmVjdG9yPHU4PicsIFsxLDIsMyw0LDUsNl0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdHlwZSB0byByZWdpc3RlclxuICAgKiBAcGFyYW0gZWxlbWVudFR5cGUgT3B0aW9uYWwgbmFtZSBvZiB0aGUgaW5uZXIgdHlwZSBvZiB0aGUgdmVjdG9yXG4gICAqIEByZXR1cm4gUmV0dXJucyBzZWxmIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ2lzdGVyVmVjdG9yVHlwZSh0eXBlTmFtZSkge1xuICAgIGxldCB7IG5hbWUsIHBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVOYW1lKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlY3RvciBjYW4gaGF2ZSBvbmx5IG9uZSB0eXBlIHBhcmFtZXRlcjsgZ290IFwiICsgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgIHR5cGVOYW1lLFxuICAgICAgZnVuY3Rpb24gZW5jb2RlVmVjdG9yKHdyaXRlciwgZGF0YSwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmVjKGRhdGEsICh3cml0ZXIyLCBlbCkgPT4ge1xuICAgICAgICAgIGxldCBlbGVtZW50VHlwZSA9IHR5cGVQYXJhbXNbMF07XG4gICAgICAgICAgaWYgKCFlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIHR5cGUgcGFyYW1ldGVycyBwYXNzZWQgYSB0byB2ZWN0b3IgJyR7dHlwZU5hbWV9J2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgeyBuYW1lOiBuYW1lMiwgcGFyYW1zOiBwYXJhbXMyIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUoZWxlbWVudFR5cGUpO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1R5cGUobmFtZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUyKS5fZW5jb2RlUmF3LmNhbGwodGhpcywgd3JpdGVyMiwgZWwsIHBhcmFtczIsIHR5cGVNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShuYW1lMiBpbiB0eXBlTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgYSBtYXRjaGluZyB0eXBlIGRlZmluaXRpb24gZm9yICR7bmFtZTJ9IGluIHZlY3RvcjsgbWFrZSBzdXJlIHlvdSBwYXNzZWQgYSBnZW5lcmljYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHsgbmFtZTogaW5uZXJOYW1lLCBwYXJhbXM6IGlubmVyUGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU1hcFtuYW1lMl0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UoaW5uZXJOYW1lKS5fZW5jb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgd3JpdGVyMixcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgaW5uZXJQYXJhbXMsXG4gICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gZGVjb2RlVmVjdG9yKHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRWZWMoKHJlYWRlcjIpID0+IHtcbiAgICAgICAgICBsZXQgZWxlbWVudFR5cGUgPSB0eXBlUGFyYW1zWzBdO1xuICAgICAgICAgIGlmICghZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiB0eXBlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIGEgdmVjdG9yICcke3R5cGVOYW1lfSdgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHsgbmFtZTogbmFtZTIsIHBhcmFtczogcGFyYW1zMiB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKGVsZW1lbnRUeXBlKTtcbiAgICAgICAgICBpZiAodGhpcy5oYXNUeXBlKG5hbWUyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZUludGVyZmFjZShuYW1lMikuX2RlY29kZVJhdy5jYWxsKHRoaXMsIHJlYWRlcjIsIHBhcmFtczIsIHR5cGVNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShuYW1lMiBpbiB0eXBlTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgYSBtYXRjaGluZyB0eXBlIGRlZmluaXRpb24gZm9yICR7bmFtZTJ9IGluIHZlY3RvcjsgbWFrZSBzdXJlIHlvdSBwYXNzZWQgYSBnZW5lcmljYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHsgbmFtZTogaW5uZXJOYW1lLCBwYXJhbXM6IGlubmVyUGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU1hcFtuYW1lMl0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UoaW5uZXJOYW1lKS5fZGVjb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgcmVhZGVyMixcbiAgICAgICAgICAgIGlubmVyUGFyYW1zLFxuICAgICAgICAgICAgdHlwZU1hcFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNhZmUgbWV0aG9kIHRvIHJlZ2lzdGVyIGEgY3VzdG9tIE1vdmUgc3RydWN0LiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSBuYW1lIG9mIHRoZVxuICAgKiBzdHJ1Y3Qgd2hpY2ggaXMgb25seSB1c2VkIG9uIHRoZSBGcm9udEVuZCBhbmQgaGFzIG5vIGFmZmVjdCBvbiBzZXJpYWxpemF0aW9uIHJlc3VsdHMsXG4gICAqIGFuZCB0aGUgc2Vjb25kIGlzIGEgc3RydWN0IGRlc2NyaXB0aW9uIHBhc3NlZCBhcyBhbiBPYmplY3QuXG4gICAqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvYmplY3QgTVVTVCBoYXZlIHRoZSBzYW1lIG9yZGVyIG9uIGFsbCBvZiB0aGUgcGxhdGZvcm1zIChpZSBpbiBNb3ZlXG4gICAqIG9yIGluIFJ1c3QpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBNb3ZlIC8gUnVzdCBzdHJ1Y3RcbiAgICogLy8gc3RydWN0IENvaW4ge1xuICAgKiAvLyAgIHZhbHVlOiB1NjQsXG4gICAqIC8vICAgb3duZXI6IHZlY3Rvcjx1OD4sIC8vIG5hbWUgLy8gVmVjPHU4PiBpbiBSdXN0XG4gICAqIC8vICAgaXNfbG9ja2VkOiBib29sLFxuICAgKiAvLyB9XG4gICAqXG4gICAqIGJjcy5yZWdpc3RlclN0cnVjdFR5cGUoJ0NvaW4nLCB7XG4gICAqICAgdmFsdWU6IGJjcy5VNjQsXG4gICAqICAgb3duZXI6IGJjcy5TVFJJTkcsXG4gICAqICAgaXNfbG9ja2VkOiBiY3MuQk9PTFxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gQ3JlYXRlZCBpbiBSdXN0IHdpdGggZGllbS9iY3NcbiAgICogLy8gbGV0IHJ1c3RfYmNzX3N0ciA9ICc4MGQxYjEwNTYwMDAwMDAwMGU0MjY5NjcyMDU3NjE2YzZjNjU3NDIwNDc3NTc5MDAnO1xuICAgKiBsZXQgcnVzdF9iY3Nfc3RyID0gWyAvLyB1c2luZyBhbiBBcnJheSBoZXJlIGFzIEJDUyB3b3JrcyB3aXRoIFVpbnQ4QXJyYXlcbiAgICogIDEyOCwgMjA5LCAxNzcsICAgNSwgIDk2LCAgMCwgIDAsXG4gICAqICAgIDAsICAxNCwgIDY2LCAxMDUsIDEwMywgMzIsIDg3LFxuICAgKiAgIDk3LCAxMDgsIDEwOCwgMTAxLCAxMTYsIDMyLCA3MSxcbiAgICogIDExNywgMTIxLCAgIDBcbiAgICogXTtcbiAgICpcbiAgICogLy8gTGV0J3MgZW5jb2RlIHRoZSB2YWx1ZSBhcyB3ZWxsXG4gICAqIGxldCB0ZXN0X3NldCA9IGJjcy5zZXIoJ0NvaW4nLCB7XG4gICAqICAgb3duZXI6ICdCaWcgV2FsbGV0IEd1eScsXG4gICAqICAgdmFsdWU6ICc0MTI0MTI0MDAwMDAnLFxuICAgKiAgIGlzX2xvY2tlZDogZmFsc2UsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zb2xlLmFzc2VydChBcnJheS5mcm9tKHRlc3Rfc2V0LnRvQnl0ZXMoKSkgPT09IHJ1c3RfYmNzX3N0ciwgJ1dob29wc2llLCByZXN1bHQgbWlzbWF0Y2gnKTtcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdHlwZSB0byByZWdpc3Rlci5cbiAgICogQHBhcmFtIGZpZWxkcyBGaWVsZHMgb2YgdGhlIHN0cnVjdC4gTXVzdCBiZSBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICogQHJldHVybiBSZXR1cm5zIEJDUyBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWdpc3RlclN0cnVjdFR5cGUodHlwZU5hbWUsIGZpZWxkcykge1xuICAgIGZvciAobGV0IGtleSBpbiBmaWVsZHMpIHtcbiAgICAgIGxldCBpbnRlcm5hbE5hbWUgPSB0aGlzLnRlbXBLZXkoKTtcbiAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1trZXldO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZmllbGRzW2tleV0gPSBpbnRlcm5hbE5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTdHJ1Y3RUeXBlKGludGVybmFsTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RydWN0ID0gT2JqZWN0LmZyZWV6ZShmaWVsZHMpO1xuICAgIGxldCBjYW5vbmljYWxPcmRlciA9IE9iamVjdC5rZXlzKHN0cnVjdCk7XG4gICAgbGV0IHsgbmFtZTogc3RydWN0TmFtZSwgcGFyYW1zOiBnZW5lcmljcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlclR5cGUoXG4gICAgICB0eXBlTmFtZSxcbiAgICAgIGZ1bmN0aW9uIGVuY29kZVN0cnVjdCh3cml0ZXIsIGRhdGEsIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtzdHJ1Y3ROYW1lfSB0byBiZSBhbiBPYmplY3QsIGdvdDogJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlUGFyYW1zLmxlbmd0aCAhPT0gZ2VuZXJpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgZ2VuZXJpYyBwYXJhbWV0ZXJzIHBhc3NlZDsgZXhwZWN0ZWQ6ICR7Z2VuZXJpY3MubGVuZ3RofSwgZ290OiAke3R5cGVQYXJhbXMubGVuZ3RofWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBjYW5vbmljYWxPcmRlcikge1xuICAgICAgICAgIGlmICghKGtleSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJ1Y3QgJHtzdHJ1Y3ROYW1lfSByZXF1aXJlcyBmaWVsZCAke2tleX06JHtzdHJ1Y3Rba2V5XX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBuYW1lOiBmaWVsZFR5cGUsIHBhcmFtczogZmllbGRQYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShcbiAgICAgICAgICAgIHN0cnVjdFtrZXldXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWdlbmVyaWNzLmluY2x1ZGVzKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VHlwZUludGVyZmFjZShmaWVsZFR5cGUpLl9lbmNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIGZpZWxkUGFyYW1zLFxuICAgICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbUlkeCA9IGdlbmVyaWNzLmluZGV4T2YoZmllbGRUeXBlKTtcbiAgICAgICAgICAgIGxldCB7IG5hbWUsIHBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVQYXJhbXNbcGFyYW1JZHhdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1R5cGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUpLl9lbmNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHdyaXRlcixcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIHR5cGVNYXApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgYSBtYXRjaGluZyB0eXBlIGRlZmluaXRpb24gZm9yICR7bmFtZX0gaW4gJHtzdHJ1Y3ROYW1lfTsgbWFrZSBzdXJlIHlvdSBwYXNzZWQgYSBnZW5lcmljYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgbmFtZTogaW5uZXJOYW1lLCBwYXJhbXM6IGlubmVyUGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU1hcFtuYW1lXSk7XG4gICAgICAgICAgICB0aGlzLmdldFR5cGVJbnRlcmZhY2UoaW5uZXJOYW1lKS5fZW5jb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIHdyaXRlcixcbiAgICAgICAgICAgICAgZGF0YVtrZXldLFxuICAgICAgICAgICAgICBpbm5lclBhcmFtcyxcbiAgICAgICAgICAgICAgdHlwZU1hcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBkZWNvZGVTdHJ1Y3QocmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIGlmICh0eXBlUGFyYW1zLmxlbmd0aCAhPT0gZ2VuZXJpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgZ2VuZXJpYyBwYXJhbWV0ZXJzIHBhc3NlZDsgZXhwZWN0ZWQ6ICR7Z2VuZXJpY3MubGVuZ3RofSwgZ290OiAke3R5cGVQYXJhbXMubGVuZ3RofWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGNhbm9uaWNhbE9yZGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBuYW1lOiBmaWVsZE5hbWUsIHBhcmFtczogZmllbGRQYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShcbiAgICAgICAgICAgIHN0cnVjdFtrZXldXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWdlbmVyaWNzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKGZpZWxkTmFtZSkuX2RlY29kZVJhdy5jYWxsKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgIGZpZWxkUGFyYW1zLFxuICAgICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbUlkeCA9IGdlbmVyaWNzLmluZGV4T2YoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGxldCB7IG5hbWUsIHBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVQYXJhbXNbcGFyYW1JZHhdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1R5cGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSkuX2RlY29kZVJhdy5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiB0eXBlTWFwKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFVuYWJsZSB0byBmaW5kIGEgbWF0Y2hpbmcgdHlwZSBkZWZpbml0aW9uIGZvciAke25hbWV9IGluICR7c3RydWN0TmFtZX07IG1ha2Ugc3VyZSB5b3UgcGFzc2VkIGEgZ2VuZXJpY2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IG5hbWU6IGlubmVyTmFtZSwgcGFyYW1zOiBpbm5lclBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVNYXBbbmFtZV0pO1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UoaW5uZXJOYW1lKS5fZGVjb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgaW5uZXJQYXJhbXMsXG4gICAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gcmVnaXN0ZXIgY3VzdG9tIGVudW0gdHlwZSB3aGVyZSBlYWNoIGludmFyaWFudCBob2xkcyB0aGUgdmFsdWUgb2YgYW5vdGhlciB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MucmVnaXN0ZXJTdHJ1Y3RUeXBlKCdDb2luJywgeyB2YWx1ZTogJ3U2NCcgfSk7XG4gICAqIGJjcy5yZWdpc3RlckVudW1UeXBlKCdNeUVudW0nLCB7XG4gICAqICBzaW5nbGU6ICdDb2luJyxcbiAgICogIG11bHRpOiAndmVjdG9yPENvaW4+JyxcbiAgICogIGVtcHR5OiBudWxsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhcbiAgICogIGJjcy5kZSgnTXlFbnVtJywgJ0FJQ1dtQUFBQUFBQScsICdiYXNlNjQnKSwgLy8geyBzaW5nbGU6IHsgdmFsdWU6IDEwMDAwMDAwIH0gfVxuICAgKiAgYmNzLmRlKCdNeUVudW0nLCAnQVFJQkFBQUFBQUFBQUFJQUFBQUFBQUFBJywgJ2Jhc2U2NCcpICAvLyB7IG11bHRpOiBbIHsgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMiB9IF0gfVxuICAgKiApXG4gICAqXG4gICAqIC8vIGFuZCBzZXJpYWxpemF0aW9uXG4gICAqIGJjcy5zZXIoJ015RW51bScsIHsgc2luZ2xlOiB7IHZhbHVlOiAxMDAwMDAwMCB9IH0pLnRvQnl0ZXMoKTtcbiAgICogYmNzLnNlcignTXlFbnVtJywgeyBtdWx0aTogWyB7IHZhbHVlOiAxIH0sIHsgdmFsdWU6IDIgfSBdIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gdmFyaWFudHNcbiAgICovXG4gIHJlZ2lzdGVyRW51bVR5cGUodHlwZU5hbWUsIHZhcmlhbnRzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhcmlhbnRzKSB7XG4gICAgICBsZXQgaW50ZXJuYWxOYW1lID0gdGhpcy50ZW1wS2V5KCk7XG4gICAgICBsZXQgdmFsdWUgPSB2YXJpYW50c1trZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyaWFudHNba2V5XSA9IGludGVybmFsTmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclN0cnVjdFR5cGUoaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzdHJ1Y3QgPSBPYmplY3QuZnJlZXplKHZhcmlhbnRzKTtcbiAgICBsZXQgY2Fub25pY2FsT3JkZXIgPSBPYmplY3Qua2V5cyhzdHJ1Y3QpO1xuICAgIGxldCB7IG5hbWUsIHBhcmFtczogY2Fub25pY2FsVHlwZVBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlclR5cGUoXG4gICAgICB0eXBlTmFtZSxcbiAgICAgIGZ1bmN0aW9uIGVuY29kZUVudW0od3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHdyaXRlIGVudW0gXCIke25hbWV9XCIsIG1pc3NpbmcgZGF0YS5cblJlY2VpdmVkOiBcIiR7ZGF0YX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbmNvcnJlY3QgZGF0YSBwYXNzZWQgaW50byBlbnVtIFwiJHtuYW1lfVwiLCBleHBlY3RlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOiBcIiR7Y2Fub25pY2FsT3JkZXIuam9pbihcbiAgICAgICAgICAgICAgXCIgfCBcIlxuICAgICAgICAgICAgKX1cIi5cblJlY2VpdmVkOiBcIiR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQga2V5ID0gT2JqZWN0LmtleXMoZGF0YSlbMF07XG4gICAgICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1wdHkgb2JqZWN0IHBhc3NlZCBhcyBpbnZhcmlhbnQgb2YgdGhlIGVudW0gXCIke25hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JkZXJCeXRlID0gY2Fub25pY2FsT3JkZXIuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAob3JkZXJCeXRlID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbmtub3duIGludmFyaWFudCBvZiB0aGUgZW51bSBcIiR7bmFtZX1cIiwgYWxsb3dlZCB2YWx1ZXM6IFwiJHtjYW5vbmljYWxPcmRlci5qb2luKFxuICAgICAgICAgICAgICBcIiB8IFwiXG4gICAgICAgICAgICApfVwiOyByZWNlaXZlZCBcIiR7a2V5fVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGludmFyaWFudCA9IGNhbm9uaWNhbE9yZGVyW29yZGVyQnl0ZV07XG4gICAgICAgIGxldCBpbnZhcmlhbnRUeXBlID0gc3RydWN0W2ludmFyaWFudF07XG4gICAgICAgIHdyaXRlci53cml0ZTgob3JkZXJCeXRlKTtcbiAgICAgICAgaWYgKGludmFyaWFudFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbUluZGV4ID0gY2Fub25pY2FsVHlwZVBhcmFtcy5pbmRleE9mKGludmFyaWFudFR5cGUpO1xuICAgICAgICBsZXQgdHlwZU9yUGFyYW0gPSBwYXJhbUluZGV4ID09PSAtMSA/IGludmFyaWFudFR5cGUgOiB0eXBlUGFyYW1zW3BhcmFtSW5kZXhdO1xuICAgICAgICB7XG4gICAgICAgICAgbGV0IHsgbmFtZTogbmFtZTIsIHBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVPclBhcmFtKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUyKS5fZW5jb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgICAgZGF0YVtrZXldLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgdHlwZU1hcFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBkZWNvZGVFbnVtKHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgICAgICBsZXQgb3JkZXJCeXRlID0gcmVhZGVyLnJlYWRVTEVCKCk7XG4gICAgICAgIGxldCBpbnZhcmlhbnQgPSBjYW5vbmljYWxPcmRlcltvcmRlckJ5dGVdO1xuICAgICAgICBsZXQgaW52YXJpYW50VHlwZSA9IHN0cnVjdFtpbnZhcmlhbnRdO1xuICAgICAgICBpZiAob3JkZXJCeXRlID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBEZWNvZGluZyB0eXBlIG1pc21hdGNoLCBleHBlY3RlZCBlbnVtIFwiJHtuYW1lfVwiIGludmFyaWFudCBpbmRleCwgcmVjZWl2ZWQgXCIke29yZGVyQnl0ZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZhcmlhbnRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHsgW2ludmFyaWFudF06IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1JbmRleCA9IGNhbm9uaWNhbFR5cGVQYXJhbXMuaW5kZXhPZihpbnZhcmlhbnRUeXBlKTtcbiAgICAgICAgbGV0IHR5cGVPclBhcmFtID0gcGFyYW1JbmRleCA9PT0gLTEgPyBpbnZhcmlhbnRUeXBlIDogdHlwZVBhcmFtc1twYXJhbUluZGV4XTtcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7IG5hbWU6IG5hbWUyLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlT3JQYXJhbSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtpbnZhcmlhbnRdOiB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZTIpLl9kZWNvZGVSYXcuY2FsbCh0aGlzLCByZWFkZXIsIHBhcmFtcywgdHlwZU1hcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgc2V0IG9mIGVuY29kZXJzL2RlY29kZXJzIGZvciBzcGVjaWZpYyB0eXBlLlxuICAgKiBNYWlubHkgdXNlZCB0byBkZWZpbmUgY3VzdG9tIHR5cGUgZGUvc2VyaWFsaXphdGlvbiBsb2dpYy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGVcbiAgICogQHJldHVybnMge1R5cGVJbnRlcmZhY2V9XG4gICAqL1xuICBnZXRUeXBlSW50ZXJmYWNlKHR5cGUpIHtcbiAgICBsZXQgdHlwZUludGVyZmFjZSA9IHRoaXMudHlwZXMuZ2V0KHR5cGUpO1xuICAgIGlmICh0eXBlb2YgdHlwZUludGVyZmFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbGV0IGNoYWluID0gW107XG4gICAgICB3aGlsZSAodHlwZW9mIHR5cGVJbnRlcmZhY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNoYWluLmluY2x1ZGVzKHR5cGVJbnRlcmZhY2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWN1cnNpdmUgZGVmaW5pdGlvbiBmb3VuZDogJHtjaGFpbi5qb2luKFwiIC0+IFwiKX0gLT4gJHt0eXBlSW50ZXJmYWNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNoYWluLnB1c2godHlwZUludGVyZmFjZSk7XG4gICAgICAgIHR5cGVJbnRlcmZhY2UgPSB0aGlzLnR5cGVzLmdldCh0eXBlSW50ZXJmYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVJbnRlcmZhY2UgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlICR7dHlwZX0gaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVJbnRlcmZhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgdHlwZSBuYW1lIGFuZCBnZXQgdGhlIHR5cGUncyBnZW5lcmljcy5cbiAgICogQGV4YW1wbGVcbiAgICogbGV0IHsgdHlwZU5hbWUsIHR5cGVQYXJhbXMgfSA9IHBhcnNlVHlwZU5hbWUoJ09wdGlvbjxDb2luPFNVST4+Jyk7XG4gICAqIC8vIHR5cGVOYW1lOiBPcHRpb25cbiAgICogLy8gdHlwZVBhcmFtczogWyAnQ29pbjxTVUk+JyBdXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHR5cGUgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0eXBlTmFtZSBhbmQgdHlwZVBhcmFtcyBsaXN0ZWQgYXMgQXJyYXlcbiAgICovXG4gIHBhcnNlVHlwZU5hbWUobmFtZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICBsZXQgW3R5cGVOYW1lMiwgLi4ucGFyYW1zMl0gPSBuYW1lO1xuICAgICAgcmV0dXJuIHsgbmFtZTogdHlwZU5hbWUyLCBwYXJhbXM6IHBhcmFtczIgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgdHlwZSBwYXNzZWQgYXMgYSBuYW1lIG9mIHRoZSB0eXBlOiAke25hbWV9YCk7XG4gICAgfVxuICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5zY2hlbWEuZ2VuZXJpY1NlcGFyYXRvcnMgfHwgW1wiPFwiLCBcIj5cIl07XG4gICAgbGV0IGxfYm91bmQgPSBuYW1lLmluZGV4T2YobGVmdCk7XG4gICAgbGV0IHJfYm91bmQgPSBBcnJheS5mcm9tKG5hbWUpLnJldmVyc2UoKS5pbmRleE9mKHJpZ2h0KTtcbiAgICBpZiAobF9ib3VuZCA9PT0gLTEgJiYgcl9ib3VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB7IG5hbWUsIHBhcmFtczogW10gfTtcbiAgICB9XG4gICAgaWYgKGxfYm91bmQgPT09IC0xIHx8IHJfYm91bmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY2xvc2VkIGdlbmVyaWMgaW4gbmFtZSAnJHtuYW1lfSdgKTtcbiAgICB9XG4gICAgbGV0IHR5cGVOYW1lID0gbmFtZS5zbGljZSgwLCBsX2JvdW5kKTtcbiAgICBsZXQgcGFyYW1zID0gc3BsaXRHZW5lcmljUGFyYW1ldGVycyhcbiAgICAgIG5hbWUuc2xpY2UobF9ib3VuZCArIDEsIG5hbWUubGVuZ3RoIC0gcl9ib3VuZCAtIDEpLFxuICAgICAgdGhpcy5zY2hlbWEuZ2VuZXJpY1NlcGFyYXRvcnNcbiAgICApO1xuICAgIHJldHVybiB7IG5hbWU6IHR5cGVOYW1lLCBwYXJhbXMgfTtcbiAgfVxufTtcbi8vIFByZWRlZmluZWQgdHlwZXMgY29uc3RhbnRzXG5fQkNTLlU4ID0gXCJ1OFwiO1xuX0JDUy5VMTYgPSBcInUxNlwiO1xuX0JDUy5VMzIgPSBcInUzMlwiO1xuX0JDUy5VNjQgPSBcInU2NFwiO1xuX0JDUy5VMTI4ID0gXCJ1MTI4XCI7XG5fQkNTLlUyNTYgPSBcInUyNTZcIjtcbl9CQ1MuQk9PTCA9IFwiYm9vbFwiO1xuX0JDUy5WRUNUT1IgPSBcInZlY3RvclwiO1xuX0JDUy5BRERSRVNTID0gXCJhZGRyZXNzXCI7XG5fQkNTLlNUUklORyA9IFwic3RyaW5nXCI7XG5fQkNTLkhFWCA9IFwiaGV4LXN0cmluZ1wiO1xuX0JDUy5CQVNFNTggPSBcImJhc2U1OC1zdHJpbmdcIjtcbl9CQ1MuQkFTRTY0ID0gXCJiYXNlNjQtc3RyaW5nXCI7XG52YXIgQkNTID0gX0JDUztcbmZ1bmN0aW9uIHJlZ2lzdGVyUHJpbWl0aXZlcyhiY3MyKSB7XG4gIGJjczIucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5VOCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGU4KGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4KCk7XG4gICAgfSxcbiAgICAodTgpID0+IHU4IDwgMjU2XG4gICk7XG4gIGJjczIucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5VMTYsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlMTYoZGF0YSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDE2KCk7XG4gICAgfSxcbiAgICAodTE2KSA9PiB1MTYgPCA2NTUzNlxuICApO1xuICBiY3MyLnJlZ2lzdGVyVHlwZShcbiAgICBCQ1MuVTMyLFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZTMyKGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMigpO1xuICAgIH0sXG4gICAgKHUzMikgPT4gdTMyIDw9IDQyOTQ5NjcyOTZuXG4gICk7XG4gIGJjczIucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5VNjQsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlNjQoZGF0YSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDY0KCk7XG4gICAgfVxuICApO1xuICBiY3MyLnJlZ2lzdGVyVHlwZShcbiAgICBCQ1MuVTEyOCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGUxMjgoZGF0YSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDEyOCgpO1xuICAgIH1cbiAgKTtcbiAgYmNzMi5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlUyNTYsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlMjU2KGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQyNTYoKTtcbiAgICB9XG4gICk7XG4gIGJjczIucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5CT09MLFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZTgoZGF0YSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDgoKS50b1N0cmluZygxMCkgPT09IFwiMVwiO1xuICAgIH1cbiAgKTtcbiAgYmNzMi5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlNUUklORyxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoQXJyYXkuZnJvbShkYXRhKSwgKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbC5jaGFyQ29kZUF0KDApKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4gcmVhZGVyMi5yZWFkOCgpKS5tYXAoKGVsKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihlbCkpKS5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgKF9zdHIpID0+IHRydWVcbiAgKTtcbiAgYmNzMi5yZWdpc3RlclR5cGUoXG4gICAgQkNTLkhFWCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoQXJyYXkuZnJvbShmcm9tSEVYKGRhdGEpKSwgKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICBsZXQgYnl0ZXMgPSByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4gcmVhZGVyMi5yZWFkOCgpKTtcbiAgICAgIHJldHVybiB0b0hFWChuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgKTtcbiAgYmNzMi5yZWdpc3RlclR5cGUoXG4gICAgQkNTLkJBU0U1OCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoQXJyYXkuZnJvbShmcm9tQjU4KGRhdGEpKSwgKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICBsZXQgYnl0ZXMgPSByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4gcmVhZGVyMi5yZWFkOCgpKTtcbiAgICAgIHJldHVybiB0b0I1OChuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgKTtcbiAgYmNzMi5yZWdpc3RlclR5cGUoXG4gICAgQkNTLkJBU0U2NCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoQXJyYXkuZnJvbShmcm9tQjY0KGRhdGEpKSwgKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICBsZXQgYnl0ZXMgPSByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4gcmVhZGVyMi5yZWFkOCgpKTtcbiAgICAgIHJldHVybiB0b0I2NChuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJ1c3RDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgZ2VuZXJpY1NlcGFyYXRvcnM6IFtcIjxcIiwgXCI+XCJdLFxuICAgIHZlY3RvclR5cGU6IFwiVmVjXCIsXG4gICAgYWRkcmVzc0xlbmd0aDogU1VJX0FERFJFU1NfTEVOR1RILFxuICAgIGFkZHJlc3NFbmNvZGluZzogXCJoZXhcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3VpTW92ZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBnZW5lcmljU2VwYXJhdG9yczogW1wiPFwiLCBcIj5cIl0sXG4gICAgdmVjdG9yVHlwZTogXCJ2ZWN0b3JcIixcbiAgICBhZGRyZXNzTGVuZ3RoOiBTVUlfQUREUkVTU19MRU5HVEgsXG4gICAgYWRkcmVzc0VuY29kaW5nOiBcImhleFwiXG4gIH07XG59XG5leHBvcnQge1xuICBCQ1MsXG4gIEJjc1JlYWRlcixcbiAgQmNzVHlwZSxcbiAgQmNzV3JpdGVyLFxuICBTZXJpYWxpemVkQmNzLFxuICBiY3MsXG4gIGRlY29kZVN0cixcbiAgZW5jb2RlU3RyLFxuICBmcm9tQjU4LFxuICBmcm9tQjY0LFxuICBmcm9tSEVYLFxuICBnZXRSdXN0Q29uZmlnLFxuICBnZXRTdWlNb3ZlQ29uZmlnLFxuICBpc1NlcmlhbGl6ZWRCY3MsXG4gIHJlZ2lzdGVyUHJpbWl0aXZlcyxcbiAgc3BsaXRHZW5lcmljUGFyYW1ldGVycyxcbiAgdG9CNTgsXG4gIHRvQjY0LFxuICB0b0hFWFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.9.0/node_modules/@mysten/bcs/dist/index.mjs\n");

/***/ })

};
;